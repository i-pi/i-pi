329d328
<         self.beads = beads
531c530
<     def bind(self, beads, cell, fcomponents, fflist, open_paths):
---
>     def bind(self, beads, cell, fcomponents, fflist):
557d555
<         self.open_paths = open_paths
582c580
<             newrpc = nm_rescale(beads.nbeads, newb,open_paths=self.open_paths)
---
>             newrpc = nm_rescale(beads.nbeads, newb,instanton=True) #ALBERTO
724c722
<         nforce.bind(nbeads, ncell, self.fcomp, self.ff,self.open_paths)
---
>         nforce.bind(nbeads, ncell, self.fcomp, self.ff)
742d739
<                 dd(dfkbself.atoms).q.set(deepcopy(dfkbref.atoms.q), manual=False)
809,820d805
<     def queue_mts(self, level):
<         """Submits all the required force calculations to the forcefields."""
< 
<         for ff in self.mforces:
<             # forces with no MTS specification are applied at the outer level
<             if ((len(ff.mts_weights) == 0 and level == 0) or
<                 (len(ff.mts_weights) > level
<                  and ff.mts_weights[level] != 0
<                  and ff.weight != 0)):
<                 # do not queue forces which have zero weight
<                 ff.queue()
< 
824d808
<         self.queue_mts(level)
831c815
<                  and self.mforces[index].weight != 0)):
---
>                  and self.mforces[index].weight > 0)):
1015d998
<         self.queue_mts(level)
1018,1020c1001
<             if (len(self.mforces[index].mts_weights) > level
<                 and self.mforces[index].mts_weights[level] != 0 and
<                 self.mforces[index].weight != 0):
---
>             if len(self.mforces[index].mts_weights) > level and self.mforces[index].mts_weights[level] != 0 and self.mforces[index].weight > 0:
