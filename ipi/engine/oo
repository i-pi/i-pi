94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100    1) """Contains the classes that evaluate forces on PI beads.
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100    2) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100    3) This contains both the class that gets the force acting on the beads,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100    4) and the class to compute individual components -- in case one wants to
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100    5) use multiple force providers to get e.g. bonded and non-bonded interactions.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100    6) It is an extra layer between the dynamics (that only cares about TOTAL force)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100    7) and the driver (that only cares about a single bead).
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100    8) """
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100    9) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   10) # This file is part of i-PI.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   11) # i-PI Copyright (C) 2014-2015 i-PI developers
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   12) # See the "licenses" directory for full license information.
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   13) 
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   14) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   15) import time
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   16) import sys
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   17) import threading
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   18) from copy import deepcopy
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   19) 
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   20) import numpy as np
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   21) 
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   22) from ipi.utils.softexit import softexit
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   23) from ipi.utils.messages import verbosity, warning, info
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   24) from ipi.utils.depend import *
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   25) from ipi.utils.nmtransform import nm_rescale
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   26) from ipi.engine.beads import Beads
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   27) 
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100   28) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   29) __all__ = ['Forces', 'ForceComponent']
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   30) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   31) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   32) fbuid = 0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   33) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   34) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   35) class ForceBead(dobject):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   36) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   37)     """Base force helper class.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   38) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   39)     This is the object that computes forces for a single bead. This is the last
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   40)     layer before calling a forcefield object.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   41) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   42)     Attributes:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   43)        atoms: An Atoms object containing all the atom positions.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   44)        cell: A Cell object containing the system box.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   45)        ff: A forcefield object which can calculate the potential, virial
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   46)           and forces given an unit cell and atom positions of one replica
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   47)           of the system.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   48)        uid: A unique id number identifying each of the different bead's
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   49)           forcefields.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   50)        request: A dictionary containing information about the currently
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   51)           running job.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   52)        _threadlock: Python handle used to lock the thread used to run the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   53)           communication with the client code.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   54)        _getallcount: An integer giving how many times the getall function has
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   55)           been called.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   56) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   57)     Depend objects:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   58)        ufvx: A list of the form [pot, f, vir]. These quantities are calculated
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   59)           all at one time by the driver, so are collected together. Each separate
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   60)           object is then taken from the list. Depends on the atom positions and
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   61)           the system box.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   62)        extra: A string containing some formatted output returned by the client. Depends on ufvx.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   63)        pot: A float giving the potential energy of the system. Depends on ufvx.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   64)        f: An array containing all the components of the force. Depends on ufvx.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   65)        fx: A slice of f containing only the x components of the forces.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   66)        fy: A slice of f containing only the y components of the forces.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   67)        fz: A slice of f containing only the z components of the forces.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   68)        vir: An array containing the components of the virial tensor in upper
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   69)           triangular form, not divided by the volume. Depends on ufvx.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   70)        request: a handle to the request that has been filed by the FF object
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   71)     """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   72) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   73)     def __init__(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   74)         """Initialises ForceBead."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   75)         dself = dd(self)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   76) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   77)         # ufvx is a list [ u, f, vir, extra ]  which stores the results of the force calculation
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   78)         dself.ufvx = depend_value(name="ufvx", func=self.get_all)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   79)         self._threadlock = threading.Lock()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   80)         self.request = None
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   81)         self._getallcount = 0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   82) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   83)     def bind(self, atoms, cell, ff):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   84)         """Binds atoms, cell and a forcefield template to the ForceBead object.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   85) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   86)         Args:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   87)            atoms: The Atoms object from which the atom positions are taken.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   88)            cell: The Cell object from which the system box is taken.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   89)            ff: A forcefield object which can calculate the potential, virial
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   90)               and forces given an unit cell and atom positions of one replica
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   91)               of the system.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   92)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   93) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   94)         global fbuid  # assign a unique identifier to each forcebead object
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   95)         with self._threadlock:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   96)             self.uid = fbuid
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   97)             fbuid += 1
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   98) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100   99)         # stores a reference to the atoms and cell we are computing forces for
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  100)         self.atoms = atoms
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  101)         self.cell = cell
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  102)         self.ff = ff
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  103)         dself = dd(self)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  104) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  105)         # ufv depends on the atomic positions and on the cell
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  106)         dself.ufvx.add_dependency(dd(self.atoms).q)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  107)         dself.ufvx.add_dependency(dd(self.cell).h)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  108) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  109)         # potential and virial are to be extracted very simply from ufv
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  110)         dself.pot = depend_value(name="pot", func=self.get_pot,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  111)                                  dependencies=[dself.ufvx])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  112) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  113)         dself.vir = depend_array(name="vir", value=np.zeros((3, 3), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  114)                                  func=self.get_vir,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  115)                                  dependencies=[dself.ufvx])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  116) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  117)         # NB: the force requires a bit more work, to define shortcuts to xyz
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  118)         # slices without calculating the force at this point.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  119)         fbase = np.zeros(atoms.natoms * 3, float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  120)         dself.f = depend_array(name="f", value=fbase, func=self.get_f,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  121)                                dependencies=[dself.ufvx])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  122) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  123)         dself.extra = depend_value(name="extra", func=self.get_extra,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  124)                                    dependencies=[dself.ufvx])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  125) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  126)         dself.fx = depend_array(name="fx", value=fbase[0:3 * atoms.natoms:3])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  127)         dself.fy = depend_array(name="fy", value=fbase[1:3 * atoms.natoms:3])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  128)         dself.fz = depend_array(name="fz", value=fbase[2:3 * atoms.natoms:3])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  129)         dcopy(dself.f, dself.fx)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  130)         dcopy(dself.f, dself.fy)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  131)         dcopy(dself.f, dself.fz)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  132) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  133)     def queue(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  134)         """Sends the job to the interface queue directly.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  135) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  136)         Allows the ForceBead object to ask for the ufvx list of each replica
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  137)         directly without going through the get_all function. This allows
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  138)         all the jobs to be sent at once, allowing them to be parallelized.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  139)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  140) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  141)         with self._threadlock:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  142)             if self.request is None and dd(self).ufvx.tainted():
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  143)                 self.request = self.ff.queue(self.atoms, self.cell, reqid=self.uid)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  144) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  145)     def get_all(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  146)         """Driver routine.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  147) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  148)         When one of the force, potential or virial are called, this sends the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  149)         atoms and cell to the client code, requesting that it calculates the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  150)         potential, forces and virial tensor. This then waits until the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  151)         driver is finished, and then returns the ufvx list.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  152) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  153)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  154)            A list of the form [potential, force, virial, extra].
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  155)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  156) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  157)         # because we thread over many systems and outputs, we might get called
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  158)         # more than once. keep track of how many times we are called so we
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  159)         # can make sure to wait until the last call has returned before we release
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  160)         with self._threadlock:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  161)             self._getallcount += 1
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  162) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  163)         # this is converting the distribution library requests into [ u, f, v ]  lists
66a35519 (Michele Ceriotti 2019-01-04 09:37:30 +0100  164)         t_start = time.time()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  165)         if self.request is None:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  166)             self.request = self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  167) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  168)         # sleeps until the request has been evaluated
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  169)         while self.request["status"] != "Done":
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  170)             if self.request["status"] == "Exit" or softexit.triggered:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  171)                 # now, this is tricky. we are stuck here and we cannot return meaningful results.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  172)                 # if we return, we may as well output wrong numbers, or mess up things.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  173)                 # so we can only call soft-exit and wait until that is done. then kill the thread
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  174)                 # we are in.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  175)                 softexit.trigger(" @ FORCES : cannot return so will die off here")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  176)                 while softexit.exiting:
66a35519 (Michele Ceriotti 2019-01-04 09:37:30 +0100  177)                     time.sleep(self.ff.latency)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  178)                 sys.exit()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  179)             time.sleep(self.ff.latency)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  180)         # print diagnostics about the elapsed time
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  181)         info("# forcefield %s evaluated in %f (queue) and %f (dispatched) sec." % (self.ff.name, self.request["t_finished"] - self.request["t_queued"], self.request["t_finished"] - self.request["t_dispatched"]), verbosity.debug)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  182) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  183)         # data has been collected, so the request can be released and a slot
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  184)         # freed up for new calculations
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  185)         result = self.request["result"]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  186) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  187)         # reduce the reservation count (and wait for all calls to return)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  188)         with self._threadlock:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  189)             self._getallcount -= 1
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  190) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  191)         # releases just once, but wait for all requests to be complete
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  192)         if self._getallcount == 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  193)             self.ff.release(self.request)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  194)             self.request = None
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  195)         else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  196)             while self._getallcount > 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  197)                 time.sleep(self.ff.latency)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  198) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  199)         return result
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  200) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  201)     def get_pot(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  202)         """Calls get_all routine of forcefield to update the potential.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  203) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  204)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  205)            Potential energy.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  206)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  207) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  208)         return self.ufvx[0]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  209) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  210)     def get_f(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  211)         """Calls get_all routine of forcefield to update the force.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  212) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  213)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  214)            An array containing all the components of the force.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  215)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  216) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  217)         return dstrip(self.ufvx[1])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  218) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  219)     def get_vir(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  220)         """Calls get_all routine of forcefield to update the virial.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  221) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  222)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  223)            An array containing the virial in upper triangular form, not divided
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  224)            by the volume.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  225)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  226) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  227)         vir = dstrip(self.ufvx[2])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  228)         vir[1, 0] = 0.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  229)         vir[2, 0:2] = 0.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  230)         return vir
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  231) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  232)     def get_extra(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  233)         """Calls get_all routine of forcefield to update the extras string.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  234) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  235)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  236)            A string containing all formatted additional output that the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  237)            client might have produced.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  238)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  239) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  240)         return self.ufvx[3]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  241) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  242) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  243) class ForceComponent(dobject):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  244)     """Computes one component (e.g. bonded interactions) of the force.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  245) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  246)     Deals with splitting the bead representation into
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  247)     separate replicas, and collecting the data from each replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  248) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  249)     Attributes:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  250)        natoms: An integer giving the number of atoms.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  251)        nbeads: An integer giving the number of beads.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  252)        name: The name of the forcefield.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  253)        _forces: A list of the forcefield objects for all the replicas.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  254)        weight: A float that will be used to weight the contribution of this
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  255)           forcefield to the total force.
66a35519 (Michele Ceriotti 2019-01-04 09:37:30 +0100  256)        mts_weights: A list of floats that will be used to weight the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  257)           contribution of this forcefield at each level of a MTS scheme
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  258)        ffield: A model to be used to create the forcefield objects for all
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  259)           the replicas of the system.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  260) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  261)     Depend objects:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  262)        f: An array containing the components of the force. Depends on each
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  263)           replica's ufvx list.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  264)        pots: A list containing the potential energy for each system replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  265)           Depends on each replica's ufvx list.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  266)        virs: A list containing the virial tensor for each system replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  267)           Depends on each replica's ufvx list.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  268)        pot: The sum of the potential energy of the replicas.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  269)        vir: The sum of the virial tensor of the replicas.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  270)        extras: Strings containing some formatted output returned by the client.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  271)           Depends on each replica's ufvx list.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  272)     """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  273) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  274)     def __init__(self, ffield, nbeads=0, weight=1.0, name="", mts_weights=None, epsilon=-0.001):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  275)         """Initializes ForceComponent
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  276) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  277)         Args:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  278)            ffield: A model to be used to create the forcefield objects for all
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  279)               the replicas of the system.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  280)            nbeads: The number of replicas.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  281)            weight: A relative weight to be given to the values obtained with this
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  282)               forcefield. When the contribution of all the forcefields is
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  283)               combined to give a total force, the contribution of this forcefield
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  284)               will be weighted by this factor.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  285)            name: The name of the forcefield.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  286)            mts_weights: Weight of forcefield at each mts level.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  287)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  288) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  289)         self.ffield = ffield
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  290)         self.name = name
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  291)         self.nbeads = nbeads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  292)         self.weight = depend_value(name="weight", value=weight)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  293)         if mts_weights is None:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  294)             self.mts_weights = np.asarray([])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  295)         else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  296)             self.mts_weights = np.asarray(mts_weights)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  297)         self.epsilon = epsilon
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  298) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  299)     def bind(self, beads, cell, fflist):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  300)         """Binds beads, cell and force to the forcefield.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  301) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  302)         Takes the beads, cell objects and makes them members of the forcefield.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  303)         Also takes the force object and copies it once for each replica of the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  304)         system, then binds each replica to one of the copies so that the force
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  305)         calculation can be parallelized. Creates the objects that will
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  306)         hold the data that the driver returns and the dependency network.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  307) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  308)         Args:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  309)            beads: Beads object from which the bead positions are taken.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  310)            cell: Cell object from which the system box is taken.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  311)            fflist: A list of forcefield objects to use to calculate the potential,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  312)               forces and virial for each replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  313)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  314)         dself = dd(self)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  315) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  316)         # stores a copy of the number of atoms and of beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  317)         self.natoms = beads.natoms
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  318)         if (self.nbeads != beads.nbeads):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  319)             raise ValueError("Binding together a Beads and a ForceBeads objects with different numbers of beads")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  320) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  321)         # creates an array of force objects, which are bound to the beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  322)         # and the cell
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  323)         if not self.ffield in fflist:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  324)             raise ValueError("Force component name '" + self.ffield + "' is not in the forcefields list")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  325) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  326)         self.ff = fflist[self.ffield]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  327) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  328)         self._forces = [];
3b27dd9f (Michele Ceriotti 2019-07-17 17:36:11 +0200  329)         self.beads = beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  330)         for b in range(self.nbeads):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  331)             new_force = ForceBead()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  332)             new_force.bind(beads[b], cell, self.ff)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  333)             self._forces.append(new_force)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  334) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  335)         # f is a big array which assembles the forces on individual beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  336)         dself.f = depend_array(name="f",
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  337)                                value=np.zeros((self.nbeads, 3 * self.natoms)),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  338)                                func=self.f_gather,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  339)                                dependencies=[dd(self._forces[b]).f for b in
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  340)                                              range(self.nbeads)])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  341) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  342)         # collection of pots and virs from individual beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  343)         dself.pots = depend_array(name="pots", value=np.zeros(self.nbeads, float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  344)                                   func=self.pot_gather,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  345)                                   dependencies=[dd(self._forces[b]).pot for b in
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  346)                                                 range(self.nbeads)])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  347)         dself.virs = depend_array(name="virs", value=np.zeros((self.nbeads, 3, 3), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  348)                                   func=self.vir_gather,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  349)                                   dependencies=[dd(self._forces[b]).vir for b in
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  350)                                                 range(self.nbeads)])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  351)         dself.extras = depend_value(name="extras", value=np.zeros(self.nbeads, float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  352)                                     func=self.extra_gather,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  353)                                     dependencies=[dd(self._forces[b]).extra for b in
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  354)                                                   range(self.nbeads)])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  355) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  356)         # total potential and total virial
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  357)         dself.pot = depend_value(name="pot", func=(lambda: self.pots.sum()),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  358)                                  dependencies=[dself.pots])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  359)         dself.vir = depend_array(name="vir", func=self.get_vir, value=np.zeros((3, 3)),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  360)                                  dependencies=[dself.virs])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  361) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  362)     def queue(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  363)         """Submits all the required force calculations to the interface."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  364) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  365)         # this should be called in functions which access u,v,f for ALL the beads,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  366)         # before accessing them. it is basically pre-queueing so that the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  367)         # distributed-computing magic can work
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  368)         for b in range(self.nbeads):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  369)             self._forces[b].queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  370) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  371)     def pot_gather(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  372)         """Obtains the potential energy for each replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  373) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  374)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  375)            A list of the potential energy of each replica of the system.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  376)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  377) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  378)         self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  379)         return np.array([b.pot for b in self._forces], float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  380) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  381)     def extra_gather(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  382)         """Obtains the potential energy for each replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  383) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  384)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  385)            A list of the potential energy of each replica of the system.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  386)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  387) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  388)         self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  389)         return [b.extra for b in self._forces]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  390) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  391)     def vir_gather(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  392)         """Obtains the virial for each replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  393) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  394)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  395)            A list of the virial of each replica of the system.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  396)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  397) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  398)         self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  399)         return np.array([b.vir for b in self._forces], float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  400) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  401)     def f_gather(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  402)         """Obtains the force vector for each replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  403) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  404)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  405)            An array with all the components of the force. Row i gives the force
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  406)            array for replica i of the system.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  407)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  408) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  409)         newf = np.zeros((self.nbeads, 3 * self.natoms), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  410)         self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  411)         for b in range(self.nbeads):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  412)             newf[b] = dstrip(self._forces[b].f)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  413) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  414)         return newf
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  415) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  416)     def get_vir(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  417)         """Sums the virial of each replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  418) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  419)         Not the actual system virial, as it has not been divided by either the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  420)         number of beads or the cell volume.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  421) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  422)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  423)             Virial sum.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  424)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  425) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  426)         vir = np.zeros((3, 3))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  427)         for v in dstrip(self.virs):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  428)             vir += v
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  429)         return vir
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  430) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  431) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  432) class ScaledForceComponent(dobject):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  433)     def __init__(self, baseforce, scaling=1):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  434) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  435)         self.bf = baseforce
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  436)         self.name = baseforce.name
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  437)         self.ffield = baseforce.ffield
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  438)         dself = dd(self)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  439)         dself.scaling = depend_value(name="scaling", value=scaling)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  440)         dself.f = depend_array(name="f",
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  441)                                func=lambda: self.scaling * self.bf.f if scaling != 0 else np.zeros((self.bf.nbeads, 3 * self.bf.natoms)),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  442)                                value=np.zeros((self.bf.nbeads, 3 * self.bf.natoms)),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  443)                                dependencies=[dd(self.bf).f, dself.scaling])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  444)         dself.pots = depend_array(name="pots",
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  445)                                   func=lambda: self.scaling * self.bf.pots if scaling != 0 else np.zeros(self.bf.nbeads),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  446)                                   value=np.zeros(self.bf.nbeads),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  447)                                   dependencies=[dd(self.bf).pots, dself.scaling])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  448)         dself.virs = depend_array(name="virs", func=lambda: self.scaling * self.bf.virs,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  449)                                   value=np.zeros((self.bf.nbeads, 3, 3)),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  450)                                   dependencies=[dd(self.bf).virs, dself.scaling])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  451)         dself.extras = depend_array(name="extras", func=lambda: self.bf.extras,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  452)                                     value=np.zeros(self.bf.nbeads),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  453)                                     dependencies=[dd(self.bf).extras])
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  454) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  455)         # total potential and total virial
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  456)         dself.pot = depend_value(name="pot", func=(lambda: self.pots.sum()),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  457)                                  dependencies=[dself.pots])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  458)         dself.vir = depend_array(name="vir", func=self.get_vir, value=np.zeros((3, 3)),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  459)                                  dependencies=[dself.virs])
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  460) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  461)         # pipes weight from the force, since the scaling is applied on top of that
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  462)         self.weight = depend_value(name="weight", value=0)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  463)         dpipe(dd(self.bf).weight, dself.weight)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  464)         self.mts_weights = self.bf.mts_weights
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  465) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  466)     def get_vir(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  467)         """Sums the virial of each replica.
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  468) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  469)         Not the actual system virial, as it has not been divided by either the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  470)         number of beads or the cell volume.
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  471) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  472)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  473)             Virial sum.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  474)         """
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  475) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  476)         vir = np.zeros((3, 3))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  477)         for v in dstrip(self.virs):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  478)             vir += v
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  479)         return vir
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  480) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  481)     def queue(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  482)         pass  # this should be taken care of when the force/potential/etc is accessed
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  483) 
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  484) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  485) class Forces(dobject):
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  486) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  487)     """Class that gathers all the forces together.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  488)     Collects many forcefield instances and parallelizes getting the forces
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  489)     in a PIMD environment.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  490) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  491)     Attributes:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  492)        natoms: An integer giving the number of atoms.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  493)        nbeads: An integer giving the number of beads.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  494)        nforces: An integer giving the number of ForceBeads objects.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  495)        mforces: A list of all the forcefield objects.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  496)        mbeads: A list of all the beads objects. Some of these may be contracted
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  497)           ring polymers, with a smaller number of beads than of the simulation.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  498)        mrpc: A list of the objects containing the functions required to
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  499)           contract the ring polymers of the different forcefields.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  500) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  501)     Depend objects:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  502)        f: An array containing the components of the force. Depends on each
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  503)           replica's ufvx list.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  504)        pots: A list containing the potential energy for each system replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  505)           Depends on each replica's ufvx list.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  506)        virs: A list containing the virial tensor for each system replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  507)           Depends on each replica's ufvx list.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  508)        extras: A list containing the "extra" strings for each replica.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  509)        pot: The sum of the potential energy of the replicas.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  510)        vir: The sum of the virial tensor of the replicas.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  511)     """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  512) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  513)     def __init__(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  514)         self.bound = False
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  515)         self.dforces = None
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  516)         self.dbeads = None
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  517)         self.dcell = None
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  518) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  519)     def add_component(self, nbeads, nrpc, nforces):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  520)         self.mrpc.append(nrpc)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  521)         self.mbeads.append(nbeads)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  522)         self.mforces.append(nforces)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  523)         self.nforces += 1
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  524)         dself = dd(self)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  525)         dforces = dd(nforces)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  526)         dself.f.add_dependency(dforces.f)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  527)         dself.pots.add_dependency(dforces.pots)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  528)         dself.virs.add_dependency(dforces.virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  529)         dself.extras.add_dependency(dforces.extras)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  530) 
eb18705e (Yair Litman      2019-08-30 12:43:05 +0200  531)     def bind(self, beads, cell, fcomponents, fflist, open_paths):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  532)         """Binds beads, cell and forces to the forcefield.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  533) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  534) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  535)         Args:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  536)            beads: Beads object from which the bead positions are taken.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  537)            cell: Cell object from which the system box is taken.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  538)            fcomponents: A list of different objects for each force type.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  539)               For example, if ring polymer contraction is being used,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  540)               then there may be separate forces for the long and short
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  541)               range part of the potential.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  542)            fflist: A list of forcefield objects to use to calculate the potential,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  543)               forces and virial for each force type. To clarify: fcomponents are the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  544)               names and parameters of forcefields that are active for a certain
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  545)               system. fflist contains the overall list of force providers,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  546)               and one typically has just one per force kind.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  547)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  548) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  549)         self.natoms = beads.natoms
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  550)         self.nbeads = beads.nbeads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  551)         self.beads = beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  552)         self.cell = cell
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  553)         self.bound = True
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  554)         self.nforces = len(fcomponents)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  555)         self.fcomp = fcomponents
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  556)         self.ff = fflist
eb18705e (Yair Litman      2019-08-30 12:43:05 +0200  557)         self.open_paths = open_paths
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  558) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  559)         # fflist should be a dictionary of forcefield objects
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  560)         self.mforces = []
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  561)         self.mbeads = []
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  562)         self.mrpc = []
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  563) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  564)         dself = dd(self)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  565) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  566)         # a "function factory" to generate functions to automatically update
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  567)         # contracted paths
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  568)         def make_rpc(rpc, beads):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  569)             return lambda: rpc.b1tob2(dstrip(beads.q))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  570) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  571)         # creates new force objects, possibly acting on contracted path
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  572)         # representations
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  573)         for fc in self.fcomp:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  574) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  575)             # creates an automatically-updated contracted beads object
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  576)             newb = fc.nbeads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  577)             # if the number of beads for this force component is unspecified,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  578)             # assume full force evaluation
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  579)             if newb == 0 or newb > beads.nbeads: newb = beads.nbeads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  580)             newforce = ForceComponent(ffield=fc.ffield, name=fc.name, nbeads=newb, weight=fc.weight, mts_weights=fc.mts_weights, epsilon=fc.epsilon)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  581)             newbeads = Beads(beads.natoms, newb)
eb18705e (Yair Litman      2019-08-30 12:43:05 +0200  582)             newrpc = nm_rescale(beads.nbeads, newb,open_paths=self.open_paths)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  583) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  584)             # the beads positions for this force components are obtained
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  585)             # automatically, when needed, as a contraction of the full beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  586)             dd(newbeads).q._func = make_rpc(newrpc, beads)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  587)             for b in newbeads:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  588)                 # must update also indirect access to the beads coordinates
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  589)                 dd(b).q._func = dd(newbeads).q._func
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  590) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  591)             # makes newbeads.q depend from beads.q
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  592)             dd(beads).q.add_dependant(dd(newbeads).q)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  593) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  594)             # now we create a new forcecomponent which is bound to newbeads!
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  595)             newforce.bind(newbeads, cell, fflist)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  596) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  597)             # adds information we will later need to the appropriate lists.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  598)             self.mbeads.append(newbeads)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  599)             self.mforces.append(newforce)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  600)             self.mrpc.append(newrpc)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  601) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  602)         # now must expose an interface that gives overall forces
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  603)         dself.f = depend_array(name="f", value=np.zeros((self.nbeads, 3 * self.natoms)),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  604)                                func=self.f_combine,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  605)                                dependencies=[dd(ff).f for ff in self.mforces])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  606) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  607)         # collection of pots and virs from individual ff objects
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  608)         dself.pots = depend_array(name="pots", value=np.zeros(self.nbeads, float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  609)                                   func=self.pot_combine,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  610)                                   dependencies=[dd(ff).pots for ff in self.mforces])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  611) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  612)         # must take care of the virials!
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  613)         dself.virs = depend_array(name="virs", value=np.zeros((self.nbeads, 3, 3), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  614)                                   func=self.vir_combine,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  615)                                   dependencies=[dd(ff).virs for ff in self.mforces])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  616) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  617)         dself.extras = depend_value(name="extras", value=np.zeros(self.nbeads, float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  618)                                     func=self.extra_combine,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  619)                                     dependencies=[dd(ff).extras for ff in self.mforces])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  620) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  621)         # total potential and total virial
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  622)         dself.pot = depend_value(name="pot", func=(lambda: self.pots.sum()),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  623)                                  dependencies=[dself.pots])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  624) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  625)         dself.vir = depend_array(name="vir", func=self.get_vir, value=np.zeros((3, 3)),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  626)                                  dependencies=[dself.virs])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  627) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  628)         # SC forces and potential
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  629)         dself.alpha = depend_value(name="alpha", value=0.0)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  630) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  631)         # The number of MTS levels
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  632)         dself.nmtslevels = depend_value(name="nmtslevels", value=0, func=self.get_nmtslevels)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  633) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  634)         # This will be piped from normalmodes
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  635)         dself.omegan2 = depend_value(name="omegan2", value=0)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  636) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  637)         # The Suzuki-Chin difference potential
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  638)         dself.potssc = depend_array(name="potssc", value=np.zeros(self.nbeads, float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  639)                                     dependencies=[dd(self.beads).m, dself.f, dself.pots, dself.alpha,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  640)                                                   dself.omegan2],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  641)                                     func=self.get_potssc)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  642) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  643)         dself.potsc = depend_value(name="potsc",
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  644)                                    dependencies=[dself.potssc],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  645)                                    func=(lambda: self.potssc.sum()))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  646) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  647)         # The coefficients of the physical and the |f|^2 terms
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  648)         dself.coeffsc_part_1 = depend_array(name="coeffsc_part_1", value=np.zeros((self.nbeads, 1), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  649)                                             func=self.get_coeffsc_part_1)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  650) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  651)         dself.coeffsc_part_2 = depend_array(name="coeffsc_part_2", value=np.zeros((self.nbeads, 1), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  652)                                             dependencies=[dself.alpha, dself.omegan2], func=self.get_coeffsc_part_2)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  653) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  654)         # A list that contains the high order component of the force and the virial
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  655)         dself.fvir_4th_order = depend_value(name="fvir_4th_order", value=[None, None],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  656)                                             dependencies=[dd(self.beads).m, dself.f, dself.pots],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  657)                                             func=self.fvir_4th_order_combine)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  658) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  659)         # The high order component of the Suzuki-Chin force.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  660)         dself.f_4th_order = depend_array(name="f_4th_order", value=np.zeros((self.nbeads, 3 * self.natoms), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  661)                                          dependencies=[dself.fvir_4th_order],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  662)                                          func=(lambda: self.fvir_4th_order[0]))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  663) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  664)         dself.fsc_part_1 = depend_array(name="fsc_part_1", value=np.zeros((self.nbeads, 3 * self.natoms), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  665)                                         dependencies=[dself.coeffsc_part_1, dself.f],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  666)                                         func=self.get_fsc_part_1)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  667) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  668)         dself.fsc_part_2 = depend_array(name="fsc_part_2", value=np.zeros((self.nbeads, 3 * self.natoms), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  669)                                         dependencies=[dself.coeffsc_part_2, dself.f_4th_order],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  670)                                         func=self.get_fsc_part_2)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  671) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  672)         dself. fsc = depend_array(name="fsc", value=np.zeros((self.nbeads, 3 * self.natoms), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  673)                                   dependencies=[dself.fsc_part_1, dself.fsc_part_2],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  674)                                   func=self.get_fsc)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  675) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  676)         # The high order component of the Suzuki-Chin virial.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  677)         dself.virs_4th_order = depend_array(name="vir_4th_order", value=np.zeros((self.nbeads, 3, 3), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  678)                                             dependencies=[dself.fvir_4th_order],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  679)                                             func=(lambda: self.fvir_4th_order[1]))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  680) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  681)         dself.virssc_part_1 = depend_array(name="virssc_part_1", value=np.zeros((self.nbeads, 3, 3), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  682)                                            dependencies=[dself.coeffsc_part_1, dself.virs],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  683)                                            func=self.get_virssc_part_1)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  684) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  685)         dself.virssc_part_2 = depend_array(name="virssc_part_2", value=np.zeros((self.nbeads, 3, 3), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  686)                                            dependencies=[dself.coeffsc_part_2, dself.virs_4th_order],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  687)                                            func=self.get_virssc_part_2)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  688) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  689)         dself.virssc = depend_array(name="virssc", value=np.zeros((self.nbeads, 3, 3), float),
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  690)                                     dependencies=[dself.virssc_part_1, dself.virssc_part_2],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  691)                                     func=self.get_virssc)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  692) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  693)         dself.virsc = depend_value(name="potsc",
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  694)                                    dependencies=[dself.potssc],
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  695)                                    func=(lambda: np.sum(self.virssc, axis=0)))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  696) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  697)         # Add dependencies from the force weights, that are applied here when the total
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  698)         # force is assembled from its components
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  699) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  700)         for fc in self.mforces:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  701)             dself.f.add_dependency(dd(fc).weight)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  702)             dself.pots.add_dependency(dd(fc).weight)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  703)             dself.virs.add_dependency(dd(fc).weight)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  704) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  705)     def copy(self, beads=None, cell=None):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  706)         """ Returns a copy of this force object that can be used to compute forces,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  707)         e.g. for use in internal loops of geometry optimizers, or for property
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  708)         calculation.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  709) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  710)         Args:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  711)            beads: Optionally, bind this to a different beads object than the one
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  712)               this Forces is currently bound
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  713)            cell: Optionally, bind this to a different cell object
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  714) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  715)         Returns: The copy of the Forces object
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  716)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  717) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  718)         if not self.bound: raise ValueError("Cannot copy a forces object that has not yet been bound.")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  719)         nforce = Forces()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  720)         nbeads = beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  721)         if nbeads is None: nbeads = self.beads
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  722)         ncell = cell
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  723)         if cell is None: ncell = self.cell
eb18705e (Yair Litman      2019-08-30 12:43:05 +0200  724)         nforce.bind(nbeads, ncell, self.fcomp, self.ff,self.open_paths)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  725)         return nforce
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  726) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  727)     def transfer_forces(self, refforce):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  728)         """Low-level function copying over the value of a second force object,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  729)         triggering updates but un-tainting this force depends themselves."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  730) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  731)         if len(self.mforces) != len(refforce.mforces):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  732)             raise ValueError("Cannot copy forces between objects with different numbers of components")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  733) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  734)         for k in xrange(len(self.mforces)):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  735)             mreff = refforce.mforces[k]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  736)             mself = self.mforces[k]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  737)             if mreff.nbeads != mself.nbeads:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  738)                 raise ValueError("Cannot copy forces between objects with different numbers of beads for the " + str(k) + "th component")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  739)             for b in xrange(mself.nbeads):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  740)                 dfkbref = dd(mreff._forces[b])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  741)                 dfkbself = dd(mself._forces[b])
3b27dd9f (Michele Ceriotti 2019-07-17 17:36:11 +0200  742)                 dd(dfkbself.atoms).q.set(deepcopy(dfkbref.atoms.q), manual=False)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  743)                 dfkbself.ufvx.set(deepcopy(dfkbref.ufvx._value), manual=False)
c95d082e (Mariana Rossi    2019-06-27 17:19:35 +0200  744)                 dfkbself.ufvx.taint(taintme=False)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  745) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  746)     def run(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  747)         """Makes the socket start looking for driver codes.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  748) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  749)         Tells the interface code to start the thread that looks for
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  750)         connection from the driver codes in a loop. Until this point no
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  751)         jobs can be queued.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  752)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  753) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  754)         for ff in self.mforces:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  755)             ff.run()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  756) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  757)     def stop(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  758)         """Makes the socket stop looking for driver codes.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  759) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  760)         Tells the interface code to stop the thread that looks for
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  761)         connection from the driver codes in a loop. After this point no
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  762)         jobs can be queued.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  763)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  764) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  765)         for ff in self.mforces:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  766)             ff.stop()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  767) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  768)     def queue(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  769)         """Submits all the required force calculations to the forcefields."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  770) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  771)         for ff in self.mforces:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  772)             if ff.weight != 0:  # do not compute forces which have zero weight
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  773)                 ff.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  774) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  775)     def get_vir(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  776)         """Sums the virial of each forcefield.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  777) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  778)         Not the actual system virial.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  779) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  780)         Returns:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  781)             Virial sum.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  782)         """
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  783) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  784)         vir = np.zeros((3, 3))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  785)         for v in dstrip(self.virs):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  786)             vir += v
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  787)         return vir
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  788) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  789)     def pots_component(self, index, weighted=True):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  790)         """Fetches the index^th component of the total potential."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  791)         if weighted:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  792)             if self.mforces[index].weight != 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  793)                 return self.mforces[index].weight * self.mrpc[index].b2tob1(self.mforces[index].pots)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  794)             else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  795)                 return 0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  796)         else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  797)             return self.mrpc[index].b2tob1(self.mforces[index].pots)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  798) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  799)     def forces_component(self, index, weighted=True):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  800)         """ Fetches the index^th component of the total force."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  801)         if weighted:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  802)             if self.mforces[index].weight != 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  803)                 return self.mforces[index].weight * self.mrpc[index].b2tob1(dstrip(self.mforces[index].f))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  804)             else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  805)                 return np.zeros((self.nbeads, self.natoms * 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  806)         else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  807)             return self.mrpc[index].b2tob1(dstrip(self.mforces[index].f))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  808) 
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  809)     def queue_mts(self, level):
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  810)         """Submits all the required force calculations to the forcefields."""
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  811) 
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  812)         for ff in self.mforces:
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  813)             # forces with no MTS specification are applied at the outer level
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  814)             if ((len(ff.mts_weights) == 0 and level == 0) or
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  815)                 (len(ff.mts_weights) > level
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  816)                  and ff.mts_weights[level] != 0
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  817)                  and ff.weight != 0)):
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  818)                 # do not queue forces which have zero weight
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  819)                 ff.queue()
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  820) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  821)     def forces_mts(self, level):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  822)         """ Fetches ONLY the forces associated with a given MTS level."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  823) 
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  824)         self.queue_mts(level)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  825)         fk = np.zeros((self.nbeads, 3 * self.natoms))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  826)         for index in range(len(self.mforces)):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  827)             # forces with no MTS specification are applied at the outer level
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  828)             if ((len(self.mforces[index].mts_weights) == 0 and level == 0) or
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  829)                 (len(self.mforces[index].mts_weights) > level
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  830)                  and self.mforces[index].mts_weights[level] != 0
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200  831)                  and self.mforces[index].weight != 0)):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  832)                 fk += self.mforces[index].weight * self.mforces[index].mts_weights[level] * self.mrpc[index].b2tob1(dstrip(self.mforces[index].f))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  833)         return fk
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  834) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  835)     def forcesvirs_4th_order(self, index):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  836)         """ Fetches the 4th order |f^2| correction to the force vector and the virial associated with a given component."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  837) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  838)         # gives an error is number of beads is not even.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  839)         if self.nbeads % 2 != 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  840)             warning("ERROR: Suzuki-Chin factorization requires even number of beads!")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  841)             exit()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  842) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  843)         # calculates the finite displacement.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  844)         fbase = dstrip(self.f)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  845)         eps = self.mforces[index].epsilon
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  846)         delta = np.abs(eps) / np.sqrt((fbase / self.beads.m3 * fbase / self.beads.m3).sum() / (self.nbeads * self.natoms))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  847)         dq = delta * fbase / self.beads.m3
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  848) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  849)         # stores the force component.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  850)         fbase = self.mrpc[index].b2tob1(dstrip(self.mforces[index].f))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  851)         vbase = np.zeros((self.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  852)         mvirs = dstrip(self.mforces[index].virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  853)         for i in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  854)             for j in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  855)                 vbase[:, i, j] += self.mrpc[index].b2tob1(mvirs[:, i, j])
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  856) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  857)         # uses a fwd difference if epsilon > 0.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  858)         if self.mforces[index].epsilon > 0.0:
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  859) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  860)             # gives an error if RPC is used with a fwd difference.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  861)             # The problem is that the finite difference is computed as [f(q + e.f) - f(q)].e^-1,
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  862)             # where f(q + e.f) is computed on a smaller rimg polymer of P / 2 beads which is made
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  863)             # by displacing the odd beads of the original ring polymer. Upon contraction,  it yields
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  864)             # a ring polymer that is different from the contracted one on which f(q) was computed.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  865)             # This makes the FD incorrect. A fix could be to ALWAYS compute the odd and the even
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  866)             # beads on two different ring polymers of P / 2 beads, but centered difference + RPC
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  867)             # seems to be a neater solution. Anyway, the cost of a CNT-DIFF in comparison to a FWD-DIFF
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  868)             # is marginal in when RPC + MTS is used.
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  869) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  870)             if self.mforces[index].nbeads != self.nbeads:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  871)                 warning("ERROR: high order PIMD + RPC works with a centered finite difference only! (Uness you find an elegant solution :))")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  872)                 exit()
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  873) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  874)             # for the case of alpha = 0, only odd beads are displaced.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  875)             if self.alpha == 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  876) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  877)                 # we use an aux force evaluator with half the number of beads.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  878)                 if self.dforces is None:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  879)                     self.dbeads = self.beads.copy(self.nbeads / 2)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  880)                     self.dcell = self.cell.copy()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  881)                     self.dforces = self.copy(self.dbeads, self.dcell)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  882) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  883)                 self.dcell.h = self.cell.h
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  884) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  885)                 f_4th_order = fbase * 0.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  886)                 v_4th_order = vbase * 0.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  887) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  888)                 # displaces odd beads only.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  889)                 self.dbeads.q = dstrip(self.beads.q)[1::2] - dq[1::2]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  890) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  891)                 # calculates the force.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  892)                 fminus = self.dforces.mrpc[index].b2tob1(dstrip(self.dforces.mforces[index].f))
^465422f (Ondrej Marsalek  2018-11-01 14:27:22 +0100  893) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  894)                 # calculates the virial.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  895)                 vminus = np.zeros((self.nbeads / 2, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  896)                 dmvirs = dstrip(self.dforces.mforces[index].virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  897)                 for i in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  898)                     for j in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  899)                         vminus[:, i, j] += self.dforces.mrpc[index].b2tob1(dmvirs[:, i, j])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  900) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  901)                 # calculates the finite difference.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  902)                 f_4th_order[1::2] = 2.0 * (fminus - fbase[1::2]) / delta
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  903)                 v_4th_order[1::2] = 2.0 * (vminus - vbase[1::2]) / delta
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  904) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  905)             # For the case of alpha != 0, all the beads are displaced.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  906)             else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  907) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  908)                 # we use an aux force evaluator with the same number of beads.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  909)                 if self.dforces is None:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  910)                     self.dbeads = self.beads.copy()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  911)                     self.dcell = self.cell.copy()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  912)                     self.dforces = self.copy(self.dbeads, self.dcell)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  913) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  914)                 self.dcell.h = self.cell.h
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  915) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  916)                 f_4th_order = fbase * 0.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  917)                 v_4th_order = vbase * 0.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  918) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  919)                 # displaces the beads.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  920)                 self.dbeads.q = self.beads.q + dq
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  921) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  922)                 # calculates the force.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  923)                 fplus = self.dforces.mrpc[index].b2tob1((dstrip(self.dforces.mforces[index].f)))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  924) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  925)                 # calculates the virial.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  926)                 vplus = np.zeros((self.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  927)                 dmvirs = dstrip(self.dforces.mforces[index].virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  928)                 for i in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  929)                     for j in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  930)                         vplus[:, i, j] += self.dforces.mrpc[index].b2tob1(dmvirs[:, i, j])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  931) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  932)                 # calculates the finite difference.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  933)                 f_4th_order = 2.0 * (fbase - fplus) / delta
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  934)                 v_4th_order = 2.0 * (vbase - vplus) / delta
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  935) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  936)         # uses a centered difference for epsilon  < 0.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  937)         if self.mforces[index].epsilon < 0.0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  938) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  939)                 # we use an aux force evaluator with the same number of beads.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  940)             if self.dforces is None:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  941)                 self.dbeads = self.beads.copy()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  942)                 self.dcell = self.cell.copy()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  943)                 self.dforces = self.copy(self.dbeads, self.dcell)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  944) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  945)             self.dcell.h = self.cell.h
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  946) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  947)             f_4th_order = fbase * 0.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  948)             v_4th_order = vbase * 0.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  949) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  950)             # for the case of alpha = 0, only odd beads are displaced.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  951)             if self.alpha == 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  952) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  953)                 # the first half of the aux beads are fwd displaced while the second half are bkwd displaced configurations.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  954)                 self.dbeads.q[:self.nbeads / 2] = dstrip(self.beads.q)[1::2] + dq[1::2]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  955)                 self.dbeads.q[-self.nbeads / 2:] = dstrip(self.beads.q)[1::2] - dq[1::2]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  956) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  957)                 # calculates the forces.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  958)                 fplusminus = self.dforces.mrpc[index].b2tob1(dstrip(self.dforces.mforces[index].f))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  959) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  960)                 # calculates the virial.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  961)                 vplusminus = np.zeros((self.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  962)                 dmvirs = dstrip(self.dforces.mforces[index].virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  963)                 for i in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  964)                     for j in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  965)                         vplusminus[:, i, j] += self.dforces.mrpc[index].b2tob1(dmvirs[:, i, j])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  966) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  967)                 # calculates the finite difference.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  968)                 for k in range(self.nbeads / 2):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  969)                     j = 2 * k + 1
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  970)                     f_4th_order[j] = 2.0 * (fplusminus[self.nbeads / 2 + k] - fplusminus[k]) / 2.0 / delta
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  971)                     v_4th_order[j] = 2.0 * (vplusminus[self.nbeads / 2 + k] - vplusminus[k]) / 2.0 / delta
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  972) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  973)             # For the case of alpha != 0, all the beads are displaced.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  974)             else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  975)                 # displaces the beads.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  976)                 self.dbeads.q = self.beads.q + dq
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  977) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  978)                 # calculates the forces.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  979)                 fplus = self.dforces.mrpc[index].b2tob1(dstrip(self.dforces.mforces[index].f))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  980) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  981)                 # calculates the virial.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  982)                 vplus = np.zeros((self.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  983)                 dmvirs = dstrip(self.dforces.mforces[index].virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  984)                 for i in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  985)                     for j in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  986)                         vplus[:, i, j] += self.dforces.mrpc[index].b2tob1(dmvirs[:, i, j])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  987) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  988)                 # displaces the beads.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  989)                 self.dbeads.q = self.beads.q - dq
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  990) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  991)                 # calculates the forces.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  992)                 fminus = self.dforces.mrpc[index].b2tob1(dstrip(self.dforces.mforces[index].f))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  993) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  994)                 # calculates the virial.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  995)                 vminus = np.zeros((self.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  996)                 dmvirs = dstrip(self.dforces.mforces[index].virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  997)                 for i in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  998)                     for j in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100  999)                         vminus[:, i, j] += self.dforces.mrpc[index].b2tob1(dmvirs[:, i, j])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1000) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1001)                 # calculates the finite difference.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1002)                 f_4th_order = 2.0 * (fminus - fplus) / 2.0 / delta
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1003)                 v_4th_order = 2.0 * (vminus - vplus) / 2.0 / delta
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1004) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1005)         # returns the 4th order |f^2| correction.
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1006)         return [f_4th_order, v_4th_order]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1007) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1008)     def vir_mts(self, level):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1009)         """ Fetches ONLY the total virial associated with a given MTS level."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1010)         return np.sum(self.virs_mts(level), axis=0)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1011) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1012)     def virs_mts(self, level):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1013)         """ Fetches ONLY the total virial associated with a given MTS level."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1014) 
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200 1015)         self.queue_mts(level)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1016)         rp = np.zeros((self.beads.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1017)         for index in range(len(self.mforces)):
2229dd60 (Michele Ceriotti 2019-06-15 20:13:15 +0200 1018)             if (len(self.mforces[index].mts_weights) > level
1926f890 (Michele Ceriotti 2019-06-15 20:08:52 +0200 1019)                 and self.mforces[index].mts_weights[level] != 0 and
2229dd60 (Michele Ceriotti 2019-06-15 20:13:15 +0200 1020)                 self.mforces[index].weight != 0):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1021)                 dv = np.zeros((self.beads.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1022)                 for i in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1023)                     for j in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1024)                         dv[:, i, j] += self.mrpc[index].b2tob1(self.mforces[index].virs[:, i, j])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1025)                 rp += self.mforces[index].weight * self.mforces[index].mts_weights[level] * dv
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1026)         return rp
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1027) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1028)     def get_nmtslevels(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1029)         """ Returns the total number of mts levels."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1030) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1031)         nm = len(self.mforces[0].mts_weights)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1032)         if all(len(x.mts_weights) == nm for x in self.mforces):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1033)             return nm
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1034)         else:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1035)             raise ValueError("The mts_weights of all the force components are not the same.")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1036) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1037)     def f_combine(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1038)         """Obtains the total force vector."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1039) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1040)         self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1041)         rf = np.zeros((self.nbeads, 3 * self.natoms), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1042)         for k in range(self.nforces):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1043)             # "expand" to the total number of beads the forces from the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1044)             # contracted one
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1045)             if self.mforces[k].weight != 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1046)                 rf += self.mforces[k].weight * self.mforces[k].mts_weights.sum() * self.mrpc[k].b2tob1(dstrip(self.mforces[k].f))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1047)         return rf
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1048) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1049)     def fvir_4th_order_combine(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1050)         """Obtains the total fourth order |f^2| correction to the force vector and the virial."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1051) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1052)         rf = np.zeros((self.nbeads, 3 * self.natoms), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1053)         rv = np.zeros((self.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1054) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1055)         for k in range(self.nforces):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1056)             if self.mforces[k].weight != 0 and self.mforces[k].mts_weights.sum() != 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1057)                 fv = dstrip(self.forcesvirs_4th_order(k))
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1058)                 rf += self.mforces[k].weight * self.mforces[k].mts_weights.sum() * fv[0]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1059)                 rv += self.mforces[k].weight * self.mforces[k].mts_weights.sum() * fv[1]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1060)         return [rf, rv]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1061) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1062)     def pot_combine(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1063)         """Obtains the potential energy for each forcefield."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1064) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1065)         self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1066)         rp = np.zeros(self.nbeads, float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1067)         for k in range(self.nforces):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1068)             # "expand" to the total number of beads the potentials from the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1069)             # contracted one
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1070)             if self.mforces[k].weight != 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1071)                 rp += self.mforces[k].weight * self.mforces[k].mts_weights.sum() * self.mrpc[k].b2tob1(self.mforces[k].pots)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1072)         return rp
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1073) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1074)     def extra_combine(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1075)         """Obtains the potential energy for each forcefield."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1076) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1077)         self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1078)         rp = ["" for b in range(self.nbeads)]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1079)         for k in range(self.nforces):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1080)             # "expand" to the total number of beads the potentials from the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1081)             # contracted one
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1082)             for b in range(self.nbeads):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1083)                 rp[b] += self.mforces[k].extras[b]
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1084)         return rp
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1085) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1086)     def vir_combine(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1087)         """Obtains the virial tensor for each forcefield."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1088) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1089)         self.queue()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1090)         rp = np.zeros((self.nbeads, 3, 3), float)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1091)         for k in range(self.nforces):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1092)             if self.mforces[k].weight != 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1093)                 virs = dstrip(self.mforces[k].virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1094)                 # "expand" to the total number of beads the virials from the
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1095)                 # contracted one, element by element
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1096)                 for i in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1097)                     for j in range(3):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1098)                         rp[:, i, j] += self.mforces[k].weight * self.mforces[k].mts_weights.sum() * self.mrpc[k].b2tob1(virs[:, i, j])
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1099)         return rp
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1100) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1101)     def get_potssc(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1102)         """Obtains Suzuki-Chin contribution to the potential."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1103)         if self.nbeads % 2 != 0:
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1104)             warning("ERROR: Suzuki-Chin factorization requires even number of beads!")
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1105)             exit()
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1106) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1107)         # this evaluates the square forces contribution to the SC potential (only the difference with the Trotter potential is returned)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1108)         return self.coeffsc_part_1.T * dstrip(self.pots) + self.coeffsc_part_2.T * np.sum(dstrip(self.f) / self.beads.m3 * dstrip(self.f), axis=1)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1109) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1110)     def get_fsc_part_1(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1111)         """Obtains the linear component of Suzuki-Chin correction to the force."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1112) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1113)         return self.coeffsc_part_1 * dstrip(self.f)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1114) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1115)     def get_fsc_part_2(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1116)         """Obtains the quadratic component of Suzuki-Chin correction to the force."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1117) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1118)         return self.coeffsc_part_2 * dstrip(self.f_4th_order)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1119) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1120)     def get_virssc_part_1(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1121)         """Obtains the linear component of Suzuki-Chin correction to the virial."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1122)         return self.coeffsc_part_1.reshape((self.beads.nbeads, 1, 1)) * dstrip(self.virs)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1123) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1124)     def get_virssc_part_2(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1125)         """Obtains the quadratic component of Suzuki-Chin correction to the virial."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1126)         return self.coeffsc_part_2.reshape((self.beads.nbeads, 1, 1)) * dstrip(self.virs_4th_order)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1127) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1128)     def get_fsc(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1129)         """Obtains the total Suzuki-Chin correction to the force."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1130)         return dstrip(self.fsc_part_1) + dstrip(self.fsc_part_2)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1131) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1132)     def get_virssc(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1133)         """Obtains the total Suzuki-Chin correction to the force."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1134)         return dstrip(self.virssc_part_1) + dstrip(self.virssc_part_2)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1135) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1136)     def get_coeffsc_part_1(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1137)         """Obtains the coefficients of the linear part of the Suzuki-Chin correction."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1138) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1139)         rc = np.zeros(self.beads.nbeads)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1140)         rc[0::2] = -1.0 / 3.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1141)         rc[1::2] = 1.0 / 3.0
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1142)         return np.asmatrix(rc).T
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1143) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1144)     def get_coeffsc_part_2(self):
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1145)         """Obtains the coefficients of the linear part of the Suzuki-Chin correction."""
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1146) 
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1147)         rc = np.zeros(self.beads.nbeads)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1148)         rc[0::2] = (self.alpha / self.omegan2 / 9.0)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1149)         rc[1::2] = ((1.0 - self.alpha) / self.omegan2 / 9.0)
94456a20 (Ondrej Marsalek  2018-11-01 20:09:59 +0100 1150)         return np.asmatrix(rc).T
