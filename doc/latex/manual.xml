<simulation verbosity='' threading='' mode='' safe_stride='' floatformat=''>
   <help> This is the top level class that deals with the running of the simulation, including holding the simulation specific properties such as the time step and outputting the data. </help>
   <verbosity_help> The level of output on stdout. </verbosity_help>
   <threading_help> Whether multiple-systems execution should be parallel. Makes execution non-reproducible due to the random number generator being used from concurrent threads. </threading_help>
   <mode_help> What kind of simulation should be run. </mode_help>
   <safe_stride_help> Consistent simulation states will be saved every this number of steps. 
Saving state entails a small overhead, so you may want to set this to the smallest output
frequency in your simulation to make i-PI faster. Use at your own risk!
 </safe_stride_help>
   <floatformat_help> A format for all printed floats. </floatformat_help>
   <verbosity_default> medium </verbosity_default>
   <threading_default> True </threading_default>
   <mode_default> md </mode_default>
   <safe_stride_default> 1 </safe_stride_default>
   <floatformat_default> %16.8e </floatformat_default>
   <verbosity_options> ['quiet', 'low', 'medium', 'high', 'debug'] </verbosity_options>
   <mode_options> ['md', 'static'] </mode_options>
   <verbosity_dtype> string </verbosity_dtype>
   <threading_dtype> boolean </threading_dtype>
   <mode_dtype> string </mode_dtype>
   <safe_stride_dtype> integer </safe_stride_dtype>
   <floatformat_dtype> string </floatformat_dtype>
   <prng>
      <help> Deals with the pseudo-random number generator. </help>
      <seed>
         <help> This is the seed number used to generate the initial state of the random number generator. </help>
         <default> 12345 </default>
         <dtype> integer </dtype>
      </seed>
      <state shape='' mode=''>
         <help> Gives the state vector for the random number generator. Avoid directly modifying this unless you are very familiar with the inner workings of the algorithm used. </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [     12345 2003863422 2690739229 1915043646 1178839775 1127561115 2079742408 4273798484 1166312027 3749681035 4196831410 4118597344  287971995 1813410356  594308087  659474306 4150741082 1743137838  884839837 2535984132 3982881906 2485184938 1369380702  249499538 1112819378 3086659512   67624572  848241415 1969787103 3856266675 1263083150 4280063370 3574353965 1040597063 2261670693 2420299142  893247800 3883455293 3932784028 2944192226  789806728 3609179089 1501254660 3049378596 1031906346 3659939519 2412600410 1222149863 1441287918  862849916 3472090142 2753004708 4224592818 2341467658  883841374  808357965 1538466713  618750769 2371378063  162894812 3687322120 3924033940  183463889 2919560884 3606494222 2052466274  792535121 1738545464 1278768321 2046873605 4055905754 1117085668 1887658657 3858598249 3849777436 3671046278 2773875141  101190352 3131413598  507298971  929924215 1297740356 1661371019 1462983365  238138280 4233677213 1044322732 2539007283 3146124717 3976138084
             3499976957 2453428881 2085447515 1112469727 2786973172  587206765 1187762273  864851521  447156487 1463252774 3451314631 3830773433 3299140040 2725230718  993142100 2785980045 2032035285 1179164943 3896117490 2554691714 3366990574 3644845296 3937109839  606604653  217555315 2436775378  223523716  474904457  967604867 2888921382 2903107500 1336313375 3712677968 1002267706  569480542 1792097427 1576339480 4155544412 1394670587 3467785251 3608391970  678857608 2552812844  510900651  699515901 2901391448 2259805706   42076593 2220133471 2265196092 2966177026 4102306189 3050943380 1897472189 1184007868 2903854626 1394012978  983121586 4024499918 2142977142 1937476233 3600314431 2681758788  603129399 2629165901 3046176198 2652035824 2302272535  930691559 3424745410  613517509  687825754 2288213284 2417432225 2527996403 2025817530 2923288173 2268070258 1355121112 2841140294 1327025022 2653438150 1709601280  284460050 3215179208 2763062113 1410345407  485041831 2956763029  175359558
              145928274 2031710991 1929306940 3101052104 3978978922 1533516070  619072541  509775148  648167192 3949903157  443321612 1872958075 1234146530 2995272016 2141814812 3493466420 3869260407 1168843913 1925853806 3016510866  604809880 3396511425 2714213716 1011751353 1453533129 4112562869  483332252 1910049371 1369522258 1179634832  904679175 3652644246  627276189 2342453446 3800052266 2727001092  193291574 2068108583 1413705432 3906723192 2057450851 4265509511   69083890 3442822233 2321107554 3869751489 2807674732 1972452681  688961100  825923809 3793074859 3457060143 2172534596 3918884231 3458980350 2162190012 3870701538 4243748274 1887119555 1052043129 3985511597 3135326103  457374651 1614898362 2647773627 1427292146 1556334293 1047586459 3224432415 1560826629  500295054 1183485953 3954888956 1166404760  497236571  136165862  964718270 2585878519 2805463467  223343024 3836840820 1106228728 1371802947 1648332305 1753849176 3169760806 1956847934 3453998566 2013917541 2010562945
             2143803534 2628122746  180043880  338694681 3142944239 1390718100 2829505757 3084276752  520801840 3941272071 1832065196  370692698 4095781020 2071502550 1333312239 2066554627 1869827816  571986956  271914460  917003501  815955875 1742706546 1265126531 2158346863 3278703399 4076317275  776424928  200186505 1804945975  639053433 3226671081 3086658175  546122111  425678666 2740587362 1916591633 2001350018 1161040098 1690904003 1222555839  636391980  848115859  352517687  196787180 1118925142  319440782 3761977922  760333794 1700201832 4279850156 1478037835 3710545267  878583410 4102751805  887268794  674360743 2272404265 2668028990 4219480308  574446012  459146358   62187993  947152105 2655748666  201480550 2022628493  473428108 3047216269 3726468285 1169452617 1932266428  282314726 2027025684 2526080928 3705290306  221403646 3304616080 3259504218 1658155897   21612469 3488524487  248871603 4157093119 2839266509 1989176845  607377439   66444447 1063920416 1200356614   64263210
              189722618 3160897803 3487011575 1381863343 3868184338 3255028770  346305395 4034255054 1495220049 1566952449 3881139570  519239688 1691362460 1711372390 3335823641 2614131385 1242267711  131909615 2359478725  312876030  745929394 2693999543 2858884327 3479696600 2349453031 3285855962 3692404255 2296929935 1881261093 3695552441 1012119528 2177546255  903123881 1434629174 3498281533 2559752705  293863355 1863055700 3850034455 3310677619  321651648  949959761 1615931015   55306865   42006825  509099970 3376282400  852414822 2071082198 4164348268 2258600293 1996435006 1512437623 1856162091 4228307248 2371157438 2121644236 1844617090 3635088209 3955776253 3819951578 1388282178 4002405397 1747164245 3674317516  258933844  241806030 3485115121 1651756326 3767193872 2620172589 4168214586 1606820141 1226810381 1419388526 3228275326  960541189  804121262  238466652 2947624963 3751770909 2560664207  473471067 4200190114 1987869249 3024649469 3933653337 2350160961 3583410991 4140322333
             1504108952 1690362912  588688329 2019514642 4157493573 4006512741 2168743942  599994205  400914043 1531745106  189959307  546625444 2543573378  711086415 3816185083 1077634985 3615543066  710219696  588220996 2650534569 4025565773 2127358109 3684123492 3784358012  273531637 3166046596 2845079994 1354727285 3270401698 4212555876  292080003 3099827600 2071875196  843111988 2381152360 1397908919 2280294580 2813024181 1921747995 2881368619  906018071 2468145918 1091408728 2175059210  380306966 3931451037 4158649414 1861701162 1737743337 3780963451 3145565516 2986235835 3361316595 2583307943 1222807057 2715328073 3208222865 1952767738 3825028611 2746075133 2677039257 1072042534 3699736830 3047049938  690804242 2948471069 3578430015 3854270385 2418910528 2889910033  860059527 2370201932  876891088 4264835867 4225968772  269682768 2166692254 1369151643 2604900562 2557330465   37363425 3214645720  179265302 4071443395 2385028310 3356130747 2574455728 3251571027 1138392746 1303019154
             1543871771 2466244447 2169638607 3538324992 3171591247 1094388098 3673611729  685303805 1168436725  789935977 2688438163 3928031068  390568355 2012011128  380368103  507002958 2965184242  146515677 2858425439 2846095328 3431383130 2626192974 2379196974 1278456207 2102136122 1655885180 4209899911 3708229451   37337504 1484578393 4037595890 3155506256 2476443798 2759858337 3828217229 1030545733 3311783801 2173249379 2161538183 3835307964 1515186079 1640755611 1291304456 4038053076 1474028059 2088116363 1842000572 1774889948  570037629 2408931742  309330138  882573905 4053550405 1621347567 3419224632 3082718874 2124782668 1511449014  701693577  741654372  385353932  438609621 1502663011 3890089989 1230604986 2326712612   82828380  638791339 3023564503 1823750506  197258393 1867463616 1602477705 3067450893 3724229969 1294865857 3037878056 1527242747 3100518924 1278875633  290120732 4083350905 1711951248  277493156]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </state>
      <has_gauss>
         <help> Determines whether there is a stored gaussian number or not. A value of 0 means there is none stored. </help>
         <default> 0 </default>
         <dtype> integer </dtype>
      </has_gauss>
      <gauss>
         <help> The stored Gaussian number. </help>
         <default> 0.0 </default>
         <dtype> float </dtype>
      </gauss>
      <set_pos>
         <help> Gives the position in the state array that the random number generator is reading from. </help>
         <default> 624 </default>
         <dtype> integer </dtype>
      </set_pos>
   </prng>
   <output prefix=''>
      <help> This class defines how properties, trajectories and checkpoints should be output during the simulation. May contain zero, one or many instances of properties, trajectory or checkpoint tags, each giving instructions on how one output file should be created and managed. </help>
      <prefix_help> A string that will be prepended to each output file name. The file name is given by 'prefix'.'filename' + format_specifier. The format specifier may also include a number if multiple similar files are output. </prefix_help>
      <prefix_default> i-pi </prefix_default>
      <prefix_dtype> string </prefix_dtype>
      <properties shape='' mode='' filename='' stride='' flush=''>
         <help> Each of the properties tags specify how to create a file in which one or more properties are written, one line per frame.  </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <filename_help> A string to specify the name of the file that is output. The file name is given by 'prefix'.'filename' + format_specifier. The format specifier may also include a number if multiple similar files are output. </filename_help>
         <stride_help> The number of steps between successive writes. </stride_help>
         <flush_help> How often should streams be flushed. 1 means each time, zero means never. </flush_help>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <filename_default> out </filename_default>
         <stride_default> 1 </stride_default>
         <flush_default> 1 </flush_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> string </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
         <filename_dtype> string </filename_dtype>
         <stride_dtype> integer </stride_dtype>
         <flush_dtype> integer </flush_dtype>
      </properties>
      <trajectory filename='' stride='' format='' cell_units='' bead='' flush='' extra_type=''>
         <help> Each of the trajectory tags specify how to create a trajectory file, containing a list of per-atom coordinate properties.  </help>
         <filename_help> A string to specify the name of the file that is output. The file name is given by 'prefix'.'filename' + format_specifier. The format specifier may also include a number if multiple similar files are output. </filename_help>
         <stride_help> The number of steps between successive writes. </stride_help>
         <format_help> The output file format. </format_help>
         <cell_units_help> The units for the cell dimensions. </cell_units_help>
         <bead_help> Print out only the specified bead. A negative value means print only one every -(bead) beads, e.g. -2 means print just the even beads, -4 one every four and so on. </bead_help>
         <flush_help> How often should streams be flushed. 1 means each time, zero means never. </flush_help>
         <extra_type_help> What extra to print from the different extra strings. </extra_type_help>
         <filename_default> traj </filename_default>
         <stride_default> 1 </stride_default>
         <format_default> xyz </format_default>
         <cell_units_default>  </cell_units_default>
         <bead_default> -1 </bead_default>
         <flush_default> 1 </flush_default>
         <extra_type_default> raw </extra_type_default>
         <format_options> ['xyz', 'pdb', 'ase'] </format_options>
         <dtype> string </dtype>
         <filename_dtype> string </filename_dtype>
         <stride_dtype> integer </stride_dtype>
         <format_dtype> string </format_dtype>
         <cell_units_dtype> string </cell_units_dtype>
         <bead_dtype> integer </bead_dtype>
         <flush_dtype> integer </flush_dtype>
         <extra_type_dtype> string </extra_type_dtype>
      </trajectory>
      <checkpoint filename='' stride='' overwrite=''>
         <help> Each of the checkpoint tags specify how to create a checkpoint file, which can be used to restart a simulation.  </help>
         <filename_help> A string to specify the name of the file that is output. The file name is given by 'prefix'.'filename' + format_specifier. The format specifier may also include a number if multiple similar files are output. </filename_help>
         <stride_help> The number of steps between successive writes. </stride_help>
         <overwrite_help> This specifies whether or not each consecutive checkpoint file will overwrite the old one. </overwrite_help>
         <filename_default> restart </filename_default>
         <stride_default> 1 </stride_default>
         <overwrite_default> True </overwrite_default>
         <dtype> integer </dtype>
         <filename_dtype> string </filename_dtype>
         <stride_dtype> integer </stride_dtype>
         <overwrite_dtype> boolean </overwrite_dtype>
      </checkpoint>
   </output>
   <step>
      <help> The current simulation time step. </help>
      <default> 0 </default>
      <dtype> integer </dtype>
   </step>
   <total_steps>
      <help> The total number of steps that will be done. If 'step' is equal to or greater than 'total_steps', then the simulation will finish. </help>
      <default> 1000 </default>
      <dtype> integer </dtype>
   </total_steps>
   <total_time>
      <help> The maximum wall clock time (in seconds). </help>
      <default> 0 </default>
      <dtype> float </dtype>
   </total_time>
   <smotion mode=''>
      <help> Options for a 'super-motion' step between system replicas </help>
      <mode_help> Kind of smotion which should be performed. </mode_help>
      <mode_options> ['dummy', 'remd', 'metad', 'dmd', 'multi'] </mode_options>
      <mode_dtype> string </mode_dtype>
      <remd>
         <help> Option for REMD simulation </help>
         <stride>
            <help> Every how often to try exchanges (on average). </help>
            <default> 1.0 </default>
            <dtype> float </dtype>
         </stride>
         <krescale>
            <help> Rescale kinetic energy upon exchanges. </help>
            <default> True </default>
            <dtype> boolean </dtype>
         </krescale>
         <swapfile>
            <help> File to keep track of replica exchanges </help>
            <default> remd_idx </default>
            <dtype> string </dtype>
         </swapfile>
         <repindex shape='' mode=''>
            <help> List of current indices of the replicas compared to the starting indices </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </repindex>
      </remd>
      <metad>
         <help> Option for REMD simulation </help>
         <metaff shape='' mode=''>
            <help> List of names of forcefields that should do metadynamics. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> string </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </metaff>
         <use_energy>
            <help>  
Transfer the potential energy value to PLUMED to use as a collective variable. 
Can only be used with classical simulations because it requires a rather hacky 
mechanism to transfer the energy of the system to the forcefield.
 </help>
            <default> False </default>
            <dtype> boolean </dtype>
         </use_energy>
      </metad>
      <dmd>
         <help> Option for driven MD simulation </help>
         <dmdff shape='' mode=''>
            <help> List of names of forcefields that should do driven MD. Accepts ffdmd forcefield types. Currently implemented (2021) for ffdmd only the driving potential similar to the one described in Bowman, .., Brown JCP 119, 646 (2003). </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> string </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </dmdff>
      </dmd>
      <smotion mode=''>
         <help> A smotion class that can be included as a member of a 'multi' Smotion. </help>
         <mode_help> Kind of smotion which should be performed. </mode_help>
         <mode_options> ['dummy', 'remd', 'metad', 'dmd', 'multi'] </mode_options>
         <mode_dtype> string </mode_dtype>
         <remd>
            <help> Option for REMD simulation </help>
            <stride>
               <help> Every how often to try exchanges (on average). </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </stride>
            <krescale>
               <help> Rescale kinetic energy upon exchanges. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </krescale>
            <swapfile>
               <help> File to keep track of replica exchanges </help>
               <default> remd_idx </default>
               <dtype> string </dtype>
            </swapfile>
            <repindex shape='' mode=''>
               <help> List of current indices of the replicas compared to the starting indices </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </repindex>
         </remd>
         <metad>
            <help> Option for REMD simulation </help>
            <metaff shape='' mode=''>
               <help> List of names of forcefields that should do metadynamics. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> string </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </metaff>
            <use_energy>
               <help>  
Transfer the potential energy value to PLUMED to use as a collective variable. 
Can only be used with classical simulations because it requires a rather hacky 
mechanism to transfer the energy of the system to the forcefield.
 </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </use_energy>
         </metad>
         <dmd>
            <help> Option for driven MD simulation </help>
            <dmdff shape='' mode=''>
               <help> List of names of forcefields that should do driven MD. Accepts ffdmd forcefield types. Currently implemented (2021) for ffdmd only the driving potential similar to the one described in Bowman, .., Brown JCP 119, 646 (2003). </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> string </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </dmdff>
         </dmd>
      </smotion>
   </smotion>
   <system prefix=''>
      <help> This is the class which holds all the data which represents a single state of the system. </help>
      <prefix_help> Prepend this string to output files generated for this system.  </prefix_help>
      <prefix_default>  </prefix_default>
      <prefix_dtype> string </prefix_dtype>
      <initialize nbeads=''>
         <help> Specifies the number of beads, and how the system should be initialized. </help>
         <nbeads_help> The number of beads. Will override any provision from inside the initializer. A ring polymer contraction scheme is used to scale down the number of beads if required. If instead the number of beads is scaled up, higher normal modes will be initialized to zero. </nbeads_help>
         <nbeads_dtype> integer </nbeads_dtype>
         <positions mode='' index='' bead=''>
            <help> Initializes atomic positions. Will take a 'units' attribute of dimension 'length' </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively.  'ase' is to read a file with the Atomic Simulation Environment.
        'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'ase', 'chk'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </positions>
         <velocities mode='' index='' bead=''>
            <help> Initializes atomic velocities. Will take a 'units' attribute of dimension 'velocity' </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 
        'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. 
        'thermal' means that the data is to be generated from a Maxwell-Boltzmann distribution at the given temperature. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'ase', 'chk', 'thermal'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </velocities>
         <momenta mode='' index='' bead=''>
            <help> Initializes atomic momenta. Will take a 'units' attribute of dimension 'momentum' </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 
        'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. 
        'thermal' means that the data is to be generated from a Maxwell-Boltzmann distribution at the given temperature. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'ase', 'chk', 'thermal'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </momenta>
         <masses mode='' index='' bead=''>
            <help> Initializes atomic masses. Will take a 'units' attribute of dimension 'mass' </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively.  'ase' is to read a file with the Atomic Simulation Environment.
        'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'ase', 'chk'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </masses>
         <labels mode='' index='' bead=''>
            <help> Initializes atomic labels </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively.  'ase' is to read a file with the Atomic Simulation Environment.
        'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. </mode_help>
            <index_help> The index of the atom for which the value will be set. If a negative value is specified, then all atoms are assumed. </index_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <mode_default> chk </mode_default>
            <index_default> -1 </index_default>
            <bead_default> -1 </bead_default>
            <mode_options> ['manual', 'xyz', 'pdb', 'ase', 'chk'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <index_dtype> integer </index_dtype>
            <bead_dtype> integer </bead_dtype>
         </labels>
         <cell mode=''>
            <help> Initializes the configuration of the cell. Will take a 'units' attribute of dimension 'length' </help>
            <mode_help> This decides whether the system box is created from a cell parameter matrix, or from the side lengths and angles between them. If 'mode' is 'manual', then 'cell' takes a 9-elements vector containing the cell matrix (row-major, lattice vectors stored in columns).  The 1st element define lattice vector a, the 2nd, 5th elements define lattice vector b, and the 3rd, 6th, 9th elements define lattice vector c. The other elements are ignored, as the cell must be aligned so that it is upper triangular. If 'mode' is 'abcABC', then 'cell' takes an array of 6 floats, the first three being the length of the sides of the system parallelopiped, and the last three being the angles (in degrees) between those sides. Angle A corresponds to the angle between sides b and c, and so on for B and C. If mode is 'abc', then this is the same as for 'abcABC', but the cell is assumed to be orthorhombic. 'pdb' and 'chk' read the cell from a PDB or a checkpoint file, respectively. </mode_help>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'pdb', 'chk', 'abc', 'abcABC'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
         </cell>
         <file mode='' bead='' cell_units=''>
            <help> Initializes everything possible for the given mode. Will take a 'units' attribute of dimension 'length'. The unit conversion will only be applied to the positions and cell parameters. The 'units' attribute is deprecated. Append a 'quantity{units}' to the comment line of the xyz or to the 'TITLE' tag of a pdb. </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 
        'chk' stands for initialization from a checkpoint file. 'ase' is to read a file with the Atomic Simulation Environment </mode_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <cell_units_help> The units for the cell dimensions. </cell_units_help>
            <mode_default> chk </mode_default>
            <bead_default> -1 </bead_default>
            <cell_units_default> automatic </cell_units_default>
            <mode_options> ['xyz', 'pdb', 'chk', 'ase'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <bead_dtype> integer </bead_dtype>
            <cell_units_dtype> string </cell_units_dtype>
         </file>
         <gle mode=''>
            <help> Initializes the additional momenta in a GLE thermostat. </help>
            <mode_help> 'chk' stands for initialization from a checkpoint file. 'manual' means that the value to initialize from is giving explicitly as a vector. </mode_help>
            <mode_default> manual </mode_default>
            <mode_options> ['chk', 'manual'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
         </gle>
      </initialize>
      <forces>
         <help> Deals with creating all the necessary forcefield objects. </help>
         <force nbeads='' weight='' fd_epsilon='' name='' forcefield=''>
            <help> The class that deals with how each forcefield contributes to the overall potential, force and virial calculation. </help>
            <nbeads_help> If the forcefield is to be evaluated on a contracted ring polymer, this gives the number of beads that are used. If not specified, the forcefield will be evaluated on the full ring polymer. </nbeads_help>
            <weight_help> A scaling factor for this forcefield, to be applied before adding the force calculated by this forcefield to the total force. </weight_help>
            <fd_epsilon_help> The finite displacement to be used for calculaing the Suzuki-Chin contribution of the force. If the value is negative, a centered finite-difference scheme will be used. [in bohr] </fd_epsilon_help>
            <name_help> An optional name to refer to this force component. </name_help>
            <forcefield_help> Mandatory. The name of the forcefield this force is referring to. </forcefield_help>
            <nbeads_default> 0 </nbeads_default>
            <weight_default> 1.0 </weight_default>
            <fd_epsilon_default> -0.001 </fd_epsilon_default>
            <name_default>  </name_default>
            <forcefield_default>  </forcefield_default>
            <nbeads_dtype> integer </nbeads_dtype>
            <weight_dtype> float </weight_dtype>
            <fd_epsilon_dtype> float </fd_epsilon_dtype>
            <name_dtype> string </name_dtype>
            <forcefield_dtype> string </forcefield_dtype>
            <mts_weights units='' shape='' mode=''>
               <help> The weight of force in each mts level starting from outer. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default>
                  [1.]
               </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </mts_weights>
            <force_extras shape='' mode=''>
               <help> A list of quantities that should be extracted from the 'extra' string returned by the forcefield,
                           that are then treated the same way as energy or forces -- that is treated as a numerical, physical
                           quantity, interpolated when changing the number of PI replicas. Same quantities from different force
                           components are summed as well. The names should correspond to entries in the JSON-formatted extra string. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> string </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </force_extras>
         </force>
      </forces>
      <ensemble>
         <help> Holds all the information that is ensemble specific, such as the temperature and the external pressure. </help>
         <temperature units=''>
            <help> The temperature of the system. </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> temperature </dimension>
            <default> 1.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </temperature>
         <pressure units=''>
            <help> The external pressure. </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> pressure </dimension>
            <default> -1.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </pressure>
         <stress units='' shape='' mode=''>
            <help> The external stress. </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> pressure </dimension>
            <default>
               [-1. -1. -1. -1. -1. -1. -1. -1. -1.]
            </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </stress>
         <eens units=''>
            <help> The ensemble contribution to the conserved quantity. </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> energy </dimension>
            <default> 0.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </eens>
         <bias>
            <help> Deals with creating all the necessary forcefield objects. </help>
            <force nbeads='' weight='' fd_epsilon='' name='' forcefield=''>
               <help> The class that deals with how each forcefield contributes to the overall potential, force and virial calculation. </help>
               <nbeads_help> If the forcefield is to be evaluated on a contracted ring polymer, this gives the number of beads that are used. If not specified, the forcefield will be evaluated on the full ring polymer. </nbeads_help>
               <weight_help> A scaling factor for this forcefield, to be applied before adding the force calculated by this forcefield to the total force. </weight_help>
               <fd_epsilon_help> The finite displacement to be used for calculaing the Suzuki-Chin contribution of the force. If the value is negative, a centered finite-difference scheme will be used. [in bohr] </fd_epsilon_help>
               <name_help> An optional name to refer to this force component. </name_help>
               <forcefield_help> Mandatory. The name of the forcefield this force is referring to. </forcefield_help>
               <nbeads_default> 0 </nbeads_default>
               <weight_default> 1.0 </weight_default>
               <fd_epsilon_default> -0.001 </fd_epsilon_default>
               <name_default>  </name_default>
               <forcefield_default>  </forcefield_default>
               <nbeads_dtype> integer </nbeads_dtype>
               <weight_dtype> float </weight_dtype>
               <fd_epsilon_dtype> float </fd_epsilon_dtype>
               <name_dtype> string </name_dtype>
               <forcefield_dtype> string </forcefield_dtype>
               <mts_weights units='' shape='' mode=''>
                  <help> The weight of force in each mts level starting from outer. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default>
                     [1.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </mts_weights>
               <force_extras shape='' mode=''>
                  <help> A list of quantities that should be extracted from the 'extra' string returned by the forcefield,
                           that are then treated the same way as energy or forces -- that is treated as a numerical, physical
                           quantity, interpolated when changing the number of PI replicas. Same quantities from different force
                           components are summed as well. The names should correspond to entries in the JSON-formatted extra string. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> string </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </force_extras>
            </force>
         </bias>
         <bias_weights shape='' mode=''>
            <help> Bias weights. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </bias_weights>
         <hamiltonian_weights shape='' mode=''>
            <help> Hamiltonian weights. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </hamiltonian_weights>
         <time units=''>
            <help> The internal time for this system </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> time </dimension>
            <default> 0.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </time>
      </ensemble>
      <motion mode=''>
         <help> Allow chosing the type of calculation to be performed. Holds all the information that is calculation specific, such as geometry optimization parameters, etc. </help>
         <mode_help> How atoms should be moved at each step in the simulatio. 'replay' means that a simulation is replayed from trajectories provided to i-PI. </mode_help>
         <mode_options> ['vibrations', 'minimize', 'replay', 'neb', 'string', 'dynamics', 'driven_dynamics', 'constrained_dynamics', 't_ramp', 'p_ramp', 'alchemy', 'atomswap', 'planetary', 'instanton', 'al-kmc', 'dummy', 'scp', 'normalmodes', 'multi'] </mode_options>
         <mode_dtype> string </mode_dtype>
         <fixcom>
            <help> This describes whether the centre of mass of the particles is fixed. </help>
            <default> True </default>
            <dtype> boolean </dtype>
         </fixcom>
         <fixatoms shape='' mode=''>
            <help> Indices of the atmoms that should be held fixed. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </fixatoms>
         <optimizer mode=''>
            <help> Option for geometry optimization </help>
            <mode_help> The geometry optimization algorithm to be used </mode_help>
            <mode_default> lbfgs </mode_default>
            <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'lbfgs', 'damped_bfgs'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <ls_options>
               <help> "Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search (as a fraction of the overall energy tolerance),
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
               <tolerance units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tolerance>
               <iter>
                  <help> Generic input value </help>
                  <default> 100 </default>
                  <dtype> integer </dtype>
               </iter>
               <step units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </step>
               <adaptive>
                  <help> Generic input value </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </adaptive>
            </ls_options>
            <exit_on_convergence>
               <help> Terminates the simulation when the convergence criteria are met. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </exit_on_convergence>
            <tolerances>
               <help> Convergence criteria for optimization. Default values are extremely conservative. Set them to appropriate values for production runs. </help>
               <energy units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1e-07 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy>
               <force units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> force </dimension>
                  <default> 0.0001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </force>
               <position units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </position>
            </tolerances>
            <biggest_step>
               <help> The maximum step size for (L)-BFGS line minimizations. </help>
               <default> 100.0 </default>
               <dtype> float </dtype>
            </biggest_step>
            <scale_lbfgs>
               <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
               <default> 2 </default>
               <dtype> integer </dtype>
            </scale_lbfgs>
            <corrections_lbfgs>
               <help> The number of past vectors to store for L-BFGS. </help>
               <default> 6 </default>
               <dtype> integer </dtype>
            </corrections_lbfgs>
            <old_pos units='' shape='' mode=''>
               <help> The previous positions in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_pos>
            <old_pot units='' shape='' mode=''>
               <help> The previous potential energy in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> energy </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_pot>
            <old_force units='' shape='' mode=''>
               <help> The previous force in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_force>
            <old_direction shape='' mode=''>
               <help> The previous direction in a CG or SD optimization. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_direction>
            <invhessian_bfgs shape='' mode=''>
               <help> Approximate inverse Hessian for BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </invhessian_bfgs>
            <hessian_trm shape='' mode=''>
               <help> Approximate Hessian for trm, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </hessian_trm>
            <tr_trm units='' shape='' mode=''>
               <help> The trust radius in trm. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </tr_trm>
            <qlist_lbfgs shape='' mode=''>
               <help> List of previous position differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </qlist_lbfgs>
            <glist_lbfgs shape='' mode=''>
               <help> List of previous gradient differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </glist_lbfgs>
         </optimizer>
         <neb_optimizer mode=''>
            <help> Option for NEB optimization </help>
            <mode_help> The geometry optimization algorithm to optimize NEB path </mode_help>
            <mode_default> fire </mode_default>
            <mode_options> ['bfgstrm', 'damped_bfgs', 'fire'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <tolerances>
               <help> Tolerance criteria to stop NEB optimization.
                           If you work with DFT, do not use these defaults.
                         </help>
               <energy units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy>
               <force units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> force </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </force>
               <position units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </position>
            </tolerances>
            <old_coord units='' shape='' mode=''>
               <help> The previous position in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_coord>
            <full_force units='' shape='' mode=''>
               <help> The previous full-dimensional force in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </full_force>
            <full_pots units='' shape='' mode=''>
               <help> Previous physical potentials of all beads. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> energy </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </full_pots>
            <old_nebpotential shape='' mode=''>
               <help> Previous NEB potential energy, which includes spring energy. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_nebpotential>
            <old_nebgradient shape='' mode=''>
               <help> The previous gradient including NEB spring forces. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_nebgradient>
            <old_direction shape='' mode=''>
               <help> The previous direction. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_direction>
            <biggest_step units=''>
               <help> The maximum atomic displacement in a single step
                           of optimizations within NEB procedure.
                           If requested step is larger, it will be downscaled so
                           that maximal atomic displacement won't exceed biggest_step.
                         </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> length </dimension>
               <default> 0.5 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </biggest_step>
            <scale_lbfgs>
               <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
               <default> 2 </default>
               <dtype> integer </dtype>
            </scale_lbfgs>
            <hessian_bfgs shape='' mode=''>
               <help> Approximate Hessian for damped_BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </hessian_bfgs>
            <qlist_lbfgs shape='' mode=''>
               <help> List of previous position differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </qlist_lbfgs>
            <glist_lbfgs shape='' mode=''>
               <help> List of previous gradient differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </glist_lbfgs>
            <corrections_lbfgs>
               <help> The number of past vectors to store for L-BFGS. </help>
               <default> 5 </default>
               <dtype> integer </dtype>
            </corrections_lbfgs>
            <dtmax_fire>
               <help> Maximum time interval per step for FIRE. </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </dtmax_fire>
            <v_fire shape='' mode=''>
               <help> Current velocity for FIRE </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </v_fire>
            <alpha_fire>
               <help> velocity mixing factor for FIRE </help>
               <default> 0.1 </default>
               <dtype> float </dtype>
            </alpha_fire>
            <N_down_fire>
               <help> consecutive steps in downhill dierction for FIRE </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </N_down_fire>
            <N_up_fire>
               <help> consecutive steps in uphill direction </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </N_up_fire>
            <dt_fire>
               <help> time per step </help>
               <default> 0.1 </default>
               <dtype> float </dtype>
            </dt_fire>
            <endpoints>
               <help> Geometry optimization of endpoints (not implemented yet) </help>
               <optimize>
                  <help> Generic input value </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </optimize>
               <algorithm>
                  <help> Generic input value </help>
                  <default> bfgs </default>
                  <dtype> string </dtype>
               </algorithm>
            </endpoints>
            <spring>
               <help> Uniform or variable spring constants along the elastic band </help>
               <varsprings>
                  <help> Generic input value </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </varsprings>
               <kappa>
                  <help> Generic input value </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </kappa>
               <kappamax>
                  <help> Generic input value </help>
                  <default> 1.5 </default>
                  <dtype> float </dtype>
               </kappamax>
               <kappamin>
                  <help> Generic input value </help>
                  <default> 0.5 </default>
                  <dtype> float </dtype>
               </kappamin>
            </spring>
            <tangent>
               <help> How to calculate tangents: simple averaging from the original 1998 paper, or the improved tangent estimate from J. Chem. Phys. 113, 9978 (2000) </help>
               <default> improved </default>
               <options> ['plain', 'improved'] </options>
               <dtype> string </dtype>
            </tangent>
            <stage>
               <help> Stage of the NEB pipeline: optimization of endpoints, NEB itself, climbing image </help>
               <default> neb </default>
               <options> ['endpoints', 'neb', 'climb'] </options>
               <dtype> string </dtype>
            </stage>
            <use_climb>
               <help> Use climbing image NEB or not </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </use_climb>
            <climb_bead>
               <help> The index of the climbing bead. </help>
               <default> -1 </default>
               <dtype> integer </dtype>
            </climb_bead>
         </neb_optimizer>
         <string_optimizer mode=''>
            <help> Option for String minimal-energy path optimization </help>
            <mode_help> The geometry optimization algorithm to optimize MEP string </mode_help>
            <mode_default> bfgstrm </mode_default>
            <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'damped_bfgs', 'lbfgs', 'fire', 'euler'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <tolerances>
               <help> Tolerance criteria to stop String optimization.
                           If you work with DFT, do not use these defaults.
                         </help>
               <energy units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy>
               <force units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> force </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </force>
               <position units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 1e-08 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </position>
            </tolerances>
            <old_coord units='' shape='' mode=''>
               <help> The previous position in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_coord>
            <full_force units='' shape='' mode=''>
               <help> The previous full-dimensional force in an optimization step. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </full_force>
            <full_pots units='' shape='' mode=''>
               <help> Previous physical potentials of all beads. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> energy </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </full_pots>
            <old_stringpotential shape='' mode=''>
               <help> Previous string potential energy. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_stringpotential>
            <old_stringgradient shape='' mode=''>
               <help> The previous gradient of the string. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_stringgradient>
            <old_direction shape='' mode=''>
               <help> The previous direction. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_direction>
            <biggest_step units=''>
               <help> The maximum atomic displacement in a single step
                           of optimizations within String MEP procedure.
                           If requested step is larger, it will be downscaled so
                           that maximal atomic displacement won't exceed biggest_step.
                         </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> length </dimension>
               <default> 0.5 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </biggest_step>
            <scale_lbfgs>
               <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
               <default> 2 </default>
               <dtype> integer </dtype>
            </scale_lbfgs>
            <hessian_bfgs shape='' mode=''>
               <help> Approximate Hessian for damped_BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </hessian_bfgs>
            <qlist_lbfgs shape='' mode=''>
               <help> List of previous position differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </qlist_lbfgs>
            <glist_lbfgs shape='' mode=''>
               <help> List of previous gradient differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </glist_lbfgs>
            <corrections_lbfgs>
               <help> The number of past vectors to store for L-BFGS. </help>
               <default> 5 </default>
               <dtype> integer </dtype>
            </corrections_lbfgs>
            <tr_trm units='' shape='' mode=''>
               <help> Starting value for the trust radius for BFGSTRM. </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default>
                  [1.]
               </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </tr_trm>
            <dtmax_fire>
               <help> Maximum time interval per step for FIRE. </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </dtmax_fire>
            <v_fire shape='' mode=''>
               <help> Current velocity for FIRE </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </v_fire>
            <alpha_fire>
               <help> velocity mixing factor for FIRE </help>
               <default> 0.1 </default>
               <dtype> float </dtype>
            </alpha_fire>
            <N_down_fire>
               <help> consecutive steps in downhill dierction for FIRE </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </N_down_fire>
            <N_up_fire>
               <help> consecutive steps in uphill direction </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </N_up_fire>
            <dt_fire>
               <help> time per step </help>
               <default> 0.1 </default>
               <dtype> float </dtype>
            </dt_fire>
            <endpoints>
               <help> Geometry optimization of endpoints (not implemented yet) </help>
               <optimize>
                  <help> Generic input value </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </optimize>
               <algorithm>
                  <help> Generic input value </help>
                  <default> bfgstrm </default>
                  <dtype> string </dtype>
               </algorithm>
            </endpoints>
            <stage>
               <help> Stage of the String pipeline: optimization of the endpoints, string opt., climbing image opt. </help>
               <default> string </default>
               <options> ['endpoints', 'string', 'climb'] </options>
               <dtype> string </dtype>
            </stage>
            <use_climb>
               <help> Use climbing image String MEP or not </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </use_climb>
            <climb_bead>
               <help> The index of the climbing bead. </help>
               <default> -1 </default>
               <dtype> integer </dtype>
            </climb_bead>
         </string_optimizer>
         <dynamics mode='' splitting=''>
            <help> Option for (path integral) molecular dynamics </help>
            <mode_help> The ensemble that will be sampled during the simulation.
                nve: constant-energy-volume; nvt: constant-temperature-volume;
                npt: constant-temperature-pressure(isotropic); nst: constant-temperature-stress(anisotropic);
                sc: Suzuki-Chin high-order NVT; scnpt: Suzuki-Chin high-order NpT;
                nvt-cc: constrained-centroid NVT;
                eda-nve: time-dependent-field driven NVE
                  </mode_help>
            <splitting_help> The Louiville splitting used for sampling the target ensemble.  </splitting_help>
            <mode_default> nve </mode_default>
            <splitting_default> obabo </splitting_default>
            <mode_options> ['nve', 'nvt', 'npt', 'nst', 'sc', 'scnpt', 'nvt-cc', 'eda-nve'] </mode_options>
            <splitting_options> ['obabo', 'baoab'] </splitting_options>
            <mode_dtype> string </mode_dtype>
            <splitting_dtype> string </splitting_dtype>
            <thermostat mode=''>
               <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
               <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
               <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ethermo units=''>
                  <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </ethermo>
               <tau units=''>
                  <help> The friction coefficient for white noise thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <pile_lambda>
                  <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </pile_lambda>
               <pile_centroid_t units=''>
                  <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> temperature </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </pile_centroid_t>
               <A units='' shape='' mode=''>
                  <help> The friction matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> frequency </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </A>
               <C units='' shape='' mode=''>
                  <help> The covariance matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> temperature </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </C>
               <s units='' shape='' mode=''>
                  <help> Input values for the additional momenta in GLE. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> ms-momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </s>
               <intau units=''>
                  <help> The inherent noise time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </intau>
               <idtau units=''>
                  <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </idtau>
               <apat units=''>
                  <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </apat>
               <flip>
                  <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                  <default> rescale </default>
                  <dtype> string </dtype>
               </flip>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
               </thermostat>
            </thermostat>
            <barostat mode=''>
               <help> Simulates an external pressure bath. </help>
               <mode_help> The type of barostat. 'isotropic' implements the Bussi-Zykova-Parrinello barostat [doi:10.1063/1.3073889] that isotropically scales the volume while sampling the isothermal isobaric ensemble. The implementation details are given in [doi:10.1016/j.cpc.2013.10.027]. 'sc-isotropic' implements the same for Suzuki-Chin path integral molecular dynamics [10.1021/acs.jctc.8b01297]. This barostat is suitable for simulating liquids. 'flexible' implements the path integral version of the Martyna-Tuckerman-Tobias-Klein barostat which incorporates full cell fluctuations while sampling the isothermal isobaric ensemble [doi:10.1063/1.478193]. This is suitable for anisotropic systems such as molecular solids. 'anisotropic' implements the Raiteri-Gale-Bussi barostat which enables cell fluctuations at constant external stress [10.1088/0953-8984/23/33/334213]. It is suitable for simulating solids at given external (non-diagonal) stresses and requires specifying a reference cell for estimating strain. Note that this ensemble is valid only within the elastic limit of small strains. For diagonal stresses (or external pressures) the 'flexible' and the 'anisotropic' modes should give very similar results. 'dummy' barostat does not do anything. </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <tau units=''>
                  <help> The time constant associated with the dynamics of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <p units='' shape='' mode=''>
                  <help> Momentum (or momenta) of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </p>
               <h0 units='' shape='' mode=''>
                  <help> Reference cell for Parrinello-Rahman-like barostats. Should be roughly equal to the mean size of the cell averaged over the trajectory. Sampling might be inaccurate if the difference is too large. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default>
                     [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </h0>
               <hfix shape='' mode=''>
                  <help> A list of the cell entries that should be held fixed (xx, yy, zz, xy, xz, yz). 'offdiagonal' is an alias for xy, xz, yz. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> string </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hfix>
            </barostat>
            <timestep units=''>
               <help> The time step. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </timestep>
            <nmts shape='' mode=''>
               <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </nmts>
         </dynamics>
         <driven_dynamics mode='' splitting=''>
            <help> Option for driven molecular dynamics </help>
            <mode_help> The ensemble that will be sampled during the simulation.
                nve: constant-energy-volume; nvt: constant-temperature-volume;
                npt: constant-temperature-pressure(isotropic); nst: constant-temperature-stress(anisotropic);
                sc: Suzuki-Chin high-order NVT; scnpt: Suzuki-Chin high-order NpT;
                nvt-cc: constrained-centroid NVT;
                eda-nve: time-dependent-field driven NVE
                  </mode_help>
            <splitting_help> The Louiville splitting used for sampling the target ensemble.  </splitting_help>
            <mode_default> nve </mode_default>
            <splitting_default> obabo </splitting_default>
            <mode_options> ['nve', 'nvt', 'npt', 'nst', 'sc', 'scnpt', 'nvt-cc', 'eda-nve'] </mode_options>
            <splitting_options> ['obabo', 'baoab'] </splitting_options>
            <mode_dtype> string </mode_dtype>
            <splitting_dtype> string </splitting_dtype>
            <efield>
               <help> The external electric field parameters:plane-wave parameters (intensity/amplitude, angular frequency, and phase) and gaussian envelope function parameters (peak time/mean of the gaussian, and pulse duration/standard deviation of the gaussian) </help>
               <amp units='' shape='' mode=''>
                  <help> The amplitude of the external electric field (in cartesian coordinates) </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> electric-field </dimension>
                  <default>
                     [0. 0. 0.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </amp>
               <freq units=''>
                  <help> The pulsation of the external electric field </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> frequency </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </freq>
               <phase units=''>
                  <help> The phase of the external electric field (in rad) </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> number </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </phase>
               <peak units=''>
                  <help> The time when the external electric field gets its maximum value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </peak>
               <sigma units=''>
                  <help> The standard deviations (time) of the gaussian envelope function of the external electric field </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> inf </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </sigma>
            </efield>
            <bec units='' shape='' mode=''>
               <help> The Born Effective Charges tensors (cartesian coordinates) </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'driver', then the array is computed on the fly. If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> number </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> none </mode_default>
               <mode_options> ['driver', 'manual', 'file', 'none'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </bec>
            <thermostat mode=''>
               <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
               <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
               <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ethermo units=''>
                  <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </ethermo>
               <tau units=''>
                  <help> The friction coefficient for white noise thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <pile_lambda>
                  <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </pile_lambda>
               <pile_centroid_t units=''>
                  <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> temperature </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </pile_centroid_t>
               <A units='' shape='' mode=''>
                  <help> The friction matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> frequency </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </A>
               <C units='' shape='' mode=''>
                  <help> The covariance matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> temperature </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </C>
               <s units='' shape='' mode=''>
                  <help> Input values for the additional momenta in GLE. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> ms-momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </s>
               <intau units=''>
                  <help> The inherent noise time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </intau>
               <idtau units=''>
                  <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </idtau>
               <apat units=''>
                  <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </apat>
               <flip>
                  <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                  <default> rescale </default>
                  <dtype> string </dtype>
               </flip>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
               </thermostat>
            </thermostat>
            <barostat mode=''>
               <help> Simulates an external pressure bath. </help>
               <mode_help> The type of barostat. 'isotropic' implements the Bussi-Zykova-Parrinello barostat [doi:10.1063/1.3073889] that isotropically scales the volume while sampling the isothermal isobaric ensemble. The implementation details are given in [doi:10.1016/j.cpc.2013.10.027]. 'sc-isotropic' implements the same for Suzuki-Chin path integral molecular dynamics [10.1021/acs.jctc.8b01297]. This barostat is suitable for simulating liquids. 'flexible' implements the path integral version of the Martyna-Tuckerman-Tobias-Klein barostat which incorporates full cell fluctuations while sampling the isothermal isobaric ensemble [doi:10.1063/1.478193]. This is suitable for anisotropic systems such as molecular solids. 'anisotropic' implements the Raiteri-Gale-Bussi barostat which enables cell fluctuations at constant external stress [10.1088/0953-8984/23/33/334213]. It is suitable for simulating solids at given external (non-diagonal) stresses and requires specifying a reference cell for estimating strain. Note that this ensemble is valid only within the elastic limit of small strains. For diagonal stresses (or external pressures) the 'flexible' and the 'anisotropic' modes should give very similar results. 'dummy' barostat does not do anything. </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <tau units=''>
                  <help> The time constant associated with the dynamics of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <p units='' shape='' mode=''>
                  <help> Momentum (or momenta) of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </p>
               <h0 units='' shape='' mode=''>
                  <help> Reference cell for Parrinello-Rahman-like barostats. Should be roughly equal to the mean size of the cell averaged over the trajectory. Sampling might be inaccurate if the difference is too large. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default>
                     [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </h0>
               <hfix shape='' mode=''>
                  <help> A list of the cell entries that should be held fixed (xx, yy, zz, xy, xz, yz). 'offdiagonal' is an alias for xy, xz, yz. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> string </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hfix>
            </barostat>
            <timestep units=''>
               <help> The time step. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </timestep>
            <nmts shape='' mode=''>
               <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </nmts>
         </driven_dynamics>
         <constrained_dynamics mode='' splitting=''>
            <help> Option for constrained classical molecular dynamics </help>
            <mode_help> The ensemble that will be sampled during the simulation.  </mode_help>
            <splitting_help> The integrator used for sampling the target ensemble.  </splitting_help>
            <mode_default> nve </mode_default>
            <splitting_default> baoab </splitting_default>
            <mode_options> ['nve', 'nvt'] </mode_options>
            <splitting_options> ['obabo', 'baoab'] </splitting_options>
            <mode_dtype> string </mode_dtype>
            <splitting_dtype> string </splitting_dtype>
            <thermostat mode=''>
               <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
               <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
               <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ethermo units=''>
                  <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </ethermo>
               <tau units=''>
                  <help> The friction coefficient for white noise thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <pile_lambda>
                  <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </pile_lambda>
               <pile_centroid_t units=''>
                  <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> temperature </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </pile_centroid_t>
               <A units='' shape='' mode=''>
                  <help> The friction matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> frequency </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </A>
               <C units='' shape='' mode=''>
                  <help> The covariance matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> temperature </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </C>
               <s units='' shape='' mode=''>
                  <help> Input values for the additional momenta in GLE. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> ms-momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </s>
               <intau units=''>
                  <help> The inherent noise time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </intau>
               <idtau units=''>
                  <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </idtau>
               <apat units=''>
                  <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </apat>
               <flip>
                  <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                  <default> rescale </default>
                  <dtype> string </dtype>
               </flip>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
               </thermostat>
            </thermostat>
            <barostat mode=''>
               <help> Simulates an external pressure bath. </help>
               <mode_help> The type of barostat. 'isotropic' implements the Bussi-Zykova-Parrinello barostat [doi:10.1063/1.3073889] that isotropically scales the volume while sampling the isothermal isobaric ensemble. The implementation details are given in [doi:10.1016/j.cpc.2013.10.027]. 'sc-isotropic' implements the same for Suzuki-Chin path integral molecular dynamics [10.1021/acs.jctc.8b01297]. This barostat is suitable for simulating liquids. 'flexible' implements the path integral version of the Martyna-Tuckerman-Tobias-Klein barostat which incorporates full cell fluctuations while sampling the isothermal isobaric ensemble [doi:10.1063/1.478193]. This is suitable for anisotropic systems such as molecular solids. 'anisotropic' implements the Raiteri-Gale-Bussi barostat which enables cell fluctuations at constant external stress [10.1088/0953-8984/23/33/334213]. It is suitable for simulating solids at given external (non-diagonal) stresses and requires specifying a reference cell for estimating strain. Note that this ensemble is valid only within the elastic limit of small strains. For diagonal stresses (or external pressures) the 'flexible' and the 'anisotropic' modes should give very similar results. 'dummy' barostat does not do anything. </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <tau units=''>
                  <help> The time constant associated with the dynamics of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <p units='' shape='' mode=''>
                  <help> Momentum (or momenta) of the piston. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </p>
               <h0 units='' shape='' mode=''>
                  <help> Reference cell for Parrinello-Rahman-like barostats. Should be roughly equal to the mean size of the cell averaged over the trajectory. Sampling might be inaccurate if the difference is too large. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default>
                     [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </h0>
               <hfix shape='' mode=''>
                  <help> A list of the cell entries that should be held fixed (xx, yy, zz, xy, xz, yz). 'offdiagonal' is an alias for xy, xz, yz. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> string </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hfix>
            </barostat>
            <timestep units=''>
               <help> The time step. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </timestep>
            <nmts shape='' mode=''>
               <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </nmts>
            <nsteps_o>
               <help> The number of sub steps used in the evolution of the thermostat (used in function step_Oc). Relevant only for GLE thermostats </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </nsteps_o>
            <nsteps_geo>
               <help> The number of sub steps used in the evolution of the geodesic flow (used in function step_Ag). </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </nsteps_geo>
            <csolver>
               <help> Define a numerical method for computing the projection operators associated with the constraint. </help>
               <tolerance>
                  <help> Tolerance value used in the Quasi-Newton iteration scheme. </help>
                  <default> 0.0001 </default>
                  <dtype> float </dtype>
               </tolerance>
               <maxit>
                  <help> Maximum number of steps used in the Quasi-Newton iteration scheme. </help>
                  <default> 1000 </default>
                  <dtype> integer </dtype>
               </maxit>
               <norm_order>
                  <help> Order of norm used to determine termination of the Quasi-newton iteration. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </norm_order>
            </csolver>
            <constraint mode=''>
               <help> Define a constraint to be applied onto atoms </help>
               <mode_help> The type of constraint.  </mode_help>
               <mode_default> distance </mode_default>
               <mode_options> ['distance', 'angle', 'eckart', 'multi', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <atoms shape='' mode=''>
                  <help> List of atoms indices that are to be constrained. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </atoms>
               <values units='' shape='' mode=''>
                  <help> List of constraint lengths. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </values>
               <constraint mode=''>
                  <help> One or more constraints that have to be considered coupled </help>
                  <mode_help> The type of constraint.  </mode_help>
                  <mode_default> distance </mode_default>
                  <mode_options> ['distance', 'angle', 'eckart', 'multi', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <atoms shape='' mode=''>
                     <help> List of atoms indices that are to be constrained. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> integer </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </atoms>
                  <values units='' shape='' mode=''>
                     <help> List of constraint lengths. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </values>
               </constraint>
            </constraint>
         </constrained_dynamics>
         <file mode='' bead='' cell_units=''>
            <help> This describes the location to read a trajectory file from. Replay syntax allows using some POSIX wildcards in the filename of trajectory files. If symbols ?*[] are found in a filename, the code expects to find exactly Nbeads files that match the provided pattern. Bead indices will be read from the files, and the files will be ordered ascendingly by their bead indices. Wildcarded files are expected to be in the folder where the simulation runs. </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 
        'chk' stands for initialization from a checkpoint file. 'ase' is to read a file with the Atomic Simulation Environment </mode_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <cell_units_help> The units for the cell dimensions. </cell_units_help>
            <default>  </default>
            <mode_default> chk </mode_default>
            <bead_default> -1 </bead_default>
            <cell_units_default> automatic </cell_units_default>
            <mode_options> ['xyz', 'pdb', 'chk', 'ase'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <bead_dtype> integer </bead_dtype>
            <cell_units_dtype> string </cell_units_dtype>
         </file>
         <vibrations mode=''>
            <help> Option for phonon computation </help>
            <mode_help> The algorithm to be used: finite differences (fd), normal modes finite differences (nmfd), and energy-scaled normal mode finite differences (enmfd). </mode_help>
            <mode_default> fd </mode_default>
            <mode_options> ['fd', 'nmfd', 'enmfd'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <pos_shift>
               <help> The finite displacement in position used to compute derivative of force. </help>
               <default> 0.01 </default>
               <dtype> float </dtype>
            </pos_shift>
            <energy_shift>
               <help> The finite displacement in energy used to compute derivative of force. </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </energy_shift>
            <output_shift>
               <help> Shift by the dynamical matrix diagonally before outputting. </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </output_shift>
            <prefix>
               <help> Prefix of the output files. </help>
               <default> phonons </default>
               <dtype> string </dtype>
            </prefix>
            <asr>
               <help> Removes the zero frequency vibrational modes depending on the symmerty of the system. </help>
               <default> none </default>
               <options> ['none', 'poly', 'lin', 'crystal'] </options>
               <dtype> string </dtype>
            </asr>
            <dynmat shape='' mode=''>
               <help> Portion of the dynamical matrix known up to now. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </dynmat>
            <refdynmat shape='' mode=''>
               <help> Portion of the refined dynamical matrix known up to now. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </refdynmat>
         </vibrations>
         <normalmodes mode=''>
            <help> Option for solving the vibrational Schroedinger's equations in normal mode coordinates. </help>
            <mode_help> The algorithm to be used: independent mode framework (imf) and vibrational self consistent field (vscf). </mode_help>
            <mode_default> imf </mode_default>
            <mode_options> ['imf', 'vscf'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <prefix>
               <help> Prefix of the output files. </help>
               <default>  </default>
               <dtype> string </dtype>
            </prefix>
            <asr>
               <help> Removes the zero frequency vibrational modes depending on the symmetry of the system for general polyatomic molecules, and periodic crystal structures. </help>
               <default> none </default>
               <options> ['none', 'poly', 'crystal'] </options>
               <dtype> string </dtype>
            </asr>
            <dynmat shape='' mode=''>
               <help> Portion of the dynamical matrix known to the current point in the calculation. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </dynmat>
            <nprim>
               <help> Number of primitive unit cells in the simulation cell. </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </nprim>
            <fnmrms>
               <help> Fraction of harmonic RMS displacement used to sample along normal mode. </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </fnmrms>
            <nevib>
               <help> Multiple of harm vibr energy up to which BO surface is sampled. </help>
               <default> 25.0 </default>
               <dtype> float </dtype>
            </nevib>
            <nint>
               <help> Integration points for Hamiltonian matrix elements. </help>
               <default> 101 </default>
               <dtype> integer </dtype>
            </nint>
            <pair_range shape='' mode=''>
               <help> The range of pair combinations of normal modes to be considered. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </pair_range>
            <nbasis>
               <help> Number of SHO states used as basis for anharmonic wvfn. </help>
               <default> 10 </default>
               <dtype> integer </dtype>
            </nbasis>
            <athresh units=''>
               <help> Convergence threshold for absolute error in vibr free energy per degree of freedom. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 3.6749322e-06 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </athresh>
            <ethresh>
               <help> Convergence thresh for fractional error in vibr free energy. </help>
               <default> 0.01 </default>
               <dtype> float </dtype>
            </ethresh>
            <alpha>
               <help> The fraction of mean field potential to mix with the result of the previous SCF iteration. </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </alpha>
            <nkbt>
               <help> Threshold for (e - e_gs)/(kB T) of vibr state to be incl in the VSCF and partition function. </help>
               <default> 4.0 </default>
               <dtype> float </dtype>
            </nkbt>
            <nexc>
               <help> Minimum number of excited n-body states to calculate (also in MP2 correction). </help>
               <default> 5 </default>
               <dtype> integer </dtype>
            </nexc>
            <mptwo>
               <help> Flag determining whether MP2 correction is calculated. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </mptwo>
            <solve>
               <help> Flag determining whether the VSCF mean field Schroedinger's equation is solved. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </solve>
            <grid>
               <help> Flag determining whether the coupling potential is gridded or not. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </grid>
            <print_mftpot>
               <help> Flag determining whether MFT potentials are printed to file. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </print_mftpot>
            <print_1b_map>
               <help> Flag determining whether the independent mode potentials are printed to file. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </print_1b_map>
            <print_2b_map>
               <help> Flag determining whether the two body mapped coupling potentials are printed to file. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </print_2b_map>
            <print_vib_density>
               <help> Flag determining whether the vibrational density (psi**2) are printed to file. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </print_vib_density>
            <threebody>
               <help> Flag determining whether three-mode coupling terms are accounted for. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </threebody>
            <nparallel>
               <help> The number of forces evaluations per i-PI step. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </nparallel>
         </normalmodes>
         <scp mode=''>
            <help> Option for self consistent phonons computation </help>
            <mode_help> The statistics to be used in the calculation of the free energy. Quantum (qn) or classical (cl) Boltzmann statistics. </mode_help>
            <mode_default> qn </mode_default>
            <mode_options> ['qn', 'cl'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <prefix>
               <help> Prefix of the output files. </help>
               <default>  </default>
               <dtype> string </dtype>
            </prefix>
            <asr>
               <help> The method used to project out zero modes coming from continuous symmetries: crystal removes the three translational modes; molecule removes the three rotational modes in addition to the translational ones. none keeps all the modes. </help>
               <default> none </default>
               <options> ['none', 'crystal', 'poly'] </options>
               <dtype> string </dtype>
            </asr>
            <random_type>
               <help> Chooses the type of random numbers. </help>
               <default> pseudo </default>
               <options> ['sobol', 'pseudo', 'file'] </options>
               <dtype> string </dtype>
            </random_type>
            <displace_mode>
               <help> The type of optimisation strategy for obtaining the mean position. sd stands for a steepest descent algorithm. ik stands for a Newton-Raphson scheme that requires the inverse of the force constant matrix iK. nmik stands for a Newton-Raphson scheme that only displaces along normal modes directions with statistically significant forces. rnmik same as nmik but performs several optimization steps using a reweighted sampling. </help>
               <default> nmik </default>
               <options> ['ik', 'sd', 'nmik', 'rnmik'] </options>
               <dtype> string </dtype>
            </displace_mode>
            <dynmat shape='' mode=''>
               <help> The dynamical matrix of the trial Hamiltonian. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </dynmat>
            <max_steps>
               <help> Maximum number of Monte carlo steps per SCP iteration. </help>
               <dtype> integer </dtype>
            </max_steps>
            <max_iter>
               <help> Maximum number of SCP iterations. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </max_iter>
            <tau>
               <help> Step size along the gradient for the sd displace_mode </help>
               <default> 1.0 </default>
               <dtype> float </dtype>
            </tau>
            <wthreshold>
               <help> Threshold on minimum Boltzmann weights before more statistics must be accumulated. </help>
               <default> 0.9 </default>
               <dtype> float </dtype>
            </wthreshold>
            <precheck>
               <help> Flag for checking statistical significance of forces before optimisation of mean position. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </precheck>
            <checkweights>
               <help> Flag for checking Boltzmann weights for whether more statistics are required. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </checkweights>
            <chop>
               <help> Threshold below which frequencies are set to zero. </help>
               <default> 1e-09 </default>
               <dtype> float </dtype>
            </chop>
            <nparallel>
               <help> The number of Monte Carlo forces to be evaluated (in parallel) per i-PI step. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </nparallel>
            <batch_weight_exponent>
               <help> The exponent used to suppress low batch weights. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </batch_weight_exponent>
         </scp>
         <alchemy mode=''>
            <help> Option for alchemical exchanges </help>
            <mode_help>   </mode_help>
            <mode_default> dummy </mode_default>
            <mode_options> ['dummy'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <names shape='' mode=''>
               <help> The names of the atoms to be to exchanged, in the format [name1, name2, ... ]. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> string </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </names>
            <nxc>
               <help> The average number of exchanges per step to be attempted  </help>
               <default> 1 </default>
               <dtype> float </dtype>
            </nxc>
            <ealc>
               <help> The contribution to the conserved quantity for the alchemical exchanger </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </ealc>
         </alchemy>
         <atomswap mode=''>
            <help> Option for Monte Carlo atom swap </help>
            <mode_help> Dummy attribute, does nothing. </mode_help>
            <mode_default> dummy </mode_default>
            <mode_options> ['dummy'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <names shape='' mode=''>
               <help> The names of the atoms to be to exchanged, in the format [name1, name2, ... ]. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> string </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </names>
            <nxc>
               <help> The average number of exchanges per step to be attempted  </help>
               <default> 1 </default>
               <dtype> float </dtype>
            </nxc>
            <ealc>
               <help> The contribution to the conserved quantity for the atom swapper </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </ealc>
         </atomswap>
         <t_ramp>
            <help> Option for temperature ramp </help>
            <t_start units=''>
               <help> Initial temperature </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </t_start>
            <t_end units=''>
               <help> Final temperature </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </t_end>
            <logscale>
               <help> Change temperature on a logarihthmic scale. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </logscale>
            <total_steps>
               <help> Total number of steps for the ramp </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </total_steps>
            <current_step>
               <help> Current step along the ramp </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </current_step>
         </t_ramp>
         <p_ramp>
            <help> Option for pressure ramp </help>
            <p_start units=''>
               <help> Initial pressure </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> pressure </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </p_start>
            <p_end units=''>
               <help> Final pressure </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> pressure </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </p_end>
            <logscale>
               <help> Change pressure on a logarihthmic scale. </help>
               <default> False </default>
               <dtype> boolean </dtype>
            </logscale>
            <total_steps>
               <help> Total number of steps for the ramp </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </total_steps>
            <current_step>
               <help> Current step along the ramp </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </current_step>
         </p_ramp>
         <instanton mode=''>
            <help> Option for Instanton optimization </help>
            <mode_help> Defines whether it is an instanton rate or instanton tunneling splitting calculaion </mode_help>
            <mode_default> rate </mode_default>
            <mode_options> ['rate', 'splitting'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <tolerances>
               <help> Convergence criteria for optimization. </help>
               <energy units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1e-05 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy>
               <force units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> force </dimension>
                  <default> 0.0001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </force>
               <position units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.001 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </position>
            </tolerances>
            <biggest_step>
               <help> The maximum step size during the optimization. </help>
               <default> 0.4 </default>
               <dtype> float </dtype>
            </biggest_step>
            <old_pos units='' shape='' mode=''>
               <help> The previous step positions during the optimization.  </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> length </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_pos>
            <old_pot units='' shape='' mode=''>
               <help> The previous step potential energy during the optimization </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> energy </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_pot>
            <old_force units='' shape='' mode=''>
               <help> The previous step force during the optimization </help>
               <units_help> The units the input data is given in. </units_help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <dimension> force </dimension>
               <default> [ ] </default>
               <units_default> automatic </units_default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_force>
            <opt>
               <help> The geometry optimization algorithm to be used.
                                            For small system sizes nichols is recomended. Lanczos is tailored for big bigger than nbeads*natoms >~38*64.
                                            NR works in both cases given that the initial guess is close to the optimized geometry.
                                            Finally lbfgs is used for tunneling splitting calculations.  </help>
               <default> None </default>
               <options> ['nichols', 'NR', 'lbfgs', 'lanczos', 'None'] </options>
               <dtype> string </dtype>
            </opt>
            <max_e units=''>
               <help> Evaluate the forces in a reduced ring polymer such that the potential energy between consecutive replicas is smaller that the provided value. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </max_e>
            <max_ms>
               <help> Evaluate the forces in a reduced ring polymer such that that mass-scaled distance in a.u. between consecutive replicas is  smaller that the provided value. </help>
               <default> 0.0 </default>
               <dtype> float </dtype>
            </max_ms>
            <discretization shape='' mode=''>
               <help> Allows to specified non uniform time discretization as proposed in J. Chem. Phys. 134, 184107 (2011) </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </discretization>
            <alt_out>
               <help> Alternative output:Prints different formatting of outputs for geometry, hessian and bead potential energies.
                                               All quantities are also accessible from typical i-pi output infrastructure.
                                               Default to 1, which prints every step. -1 will suppress the output (except the last one).
                                               Any other positive number will set the frequency (in steps) with which the quantities are
                                               written to file.
                                               The instanton geometry is printed in xyz format and the distances are in angrstroms
                                               The hessian is printed in one line with the following format:
                                               h1_1,h2_1,...,hN_1,   h2_2,h2_2,hN_2,   ....   ,h1_d,h2_d,...,hN_d.
                                               Where N represents the total number of replicas, d the number of dimension of each replica (3*n_atoms) and
                                               hi_j means the row j of the physical hessian corresponding to the replica i.
                                               The physical hessian uses a convention according to the positions convention used in  i-pi.
                                               Example of 2 particles, the first two rows of the physical hessian reads:
                                               'H_x1_x1, H_x1_y1, H_x1_z1, H_x1_x2, H_x1_y2,H_x1_z2'
                                               'H_x2_x1, H_x2_y1, H_x2_z1, H_x2_x2, H_x2_y2,H_x2_z2'  </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </alt_out>
            <prefix>
               <help> Prefix of the output files. </help>
               <default> instanton </default>
               <dtype> string </dtype>
            </prefix>
            <delta>
               <help> Initial stretch amplitude. </help>
               <default> 0.1 </default>
               <dtype> float </dtype>
            </delta>
            <hessian_init>
               <help> How to initialize the hessian if it is not fully provided. </help>
               <default> false </default>
               <options> ['true', 'false'] </options>
               <dtype> string </dtype>
            </hessian_init>
            <hessian shape='' mode=''>
               <help> (Approximate) Hessian. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </hessian>
            <hessian_update>
               <help> How to update the hessian after each step. </help>
               <default> powell </default>
               <options> ['powell', 'recompute'] </options>
               <dtype> string </dtype>
            </hessian_update>
            <hessian_asr>
               <help> Removes the zero frequency vibrational modes depending on the symmetry of the system. </help>
               <default> none </default>
               <options> ['none', 'poly', 'crystal'] </options>
               <dtype> string </dtype>
            </hessian_asr>
            <qlist_lbfgs shape='' mode=''>
               <help> List of previous position differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </qlist_lbfgs>
            <glist_lbfgs shape='' mode=''>
               <help> List of previous gradient differences for L-BFGS, if known. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </glist_lbfgs>
            <old_direction shape='' mode=''>
               <help> The previous direction in a CG or SD optimization. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> float </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </old_direction>
            <scale_lbfgs>
               <help> Scale choice for the initial hessian.
                                                       0 identity.
                                                       1 Use first member of position/gradient list.
                                                       2 Use last  member of position/gradient list. </help>
               <default> 2 </default>
               <dtype> integer </dtype>
            </scale_lbfgs>
            <corrections_lbfgs>
               <help> The number of past vectors to store for L-BFGS. </help>
               <default> 20 </default>
               <dtype> integer </dtype>
            </corrections_lbfgs>
            <ls_options>
               <help> Options for line search methods. Includes:
                                  tolerance: stopping tolerance for the search,
                                  iter: the maximum number of iterations,
                                  step: initial step for bracketing,
                                  adaptive: whether to update initial step.
                                   </help>
               <tolerance units=''>
                  <help> Generic input value </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.2 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tolerance>
               <iter>
                  <help> Generic input value </help>
                  <default> 100 </default>
                  <dtype> integer </dtype>
               </iter>
            </ls_options>
            <energy_shift units=''>
               <help> Set the zero of energy. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </energy_shift>
            <hessian_final>
               <help> Decide if we are going to compute the final big-hessian by finite difference. </help>
               <default> false </default>
               <options> ['false', 'true'] </options>
               <dtype> string </dtype>
            </hessian_final>
         </instanton>
         <al6xxx_kmc mode=''>
            <help> Option for Al-6xxx KMC </help>
            <mode_help> The KMC algorithm to be used </mode_help>
            <mode_default> rfkmc </mode_default>
            <mode_options> ['rfkmc'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <optimizer mode=''>
               <help> Option for geometry optimization step </help>
               <mode_help> The geometry optimization algorithm to be used </mode_help>
               <mode_default> lbfgs </mode_default>
               <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'lbfgs', 'damped_bfgs'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ls_options>
                  <help> "Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search (as a fraction of the overall energy tolerance),
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
                  <tolerance units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tolerance>
                  <iter>
                     <help> Generic input value </help>
                     <default> 100 </default>
                     <dtype> integer </dtype>
                  </iter>
                  <step units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </step>
                  <adaptive>
                     <help> Generic input value </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </adaptive>
               </ls_options>
               <exit_on_convergence>
                  <help> Terminates the simulation when the convergence criteria are met. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </exit_on_convergence>
               <tolerances>
                  <help> Convergence criteria for optimization. Default values are extremely conservative. Set them to appropriate values for production runs. </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-07 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <biggest_step>
                  <help> The maximum step size for (L)-BFGS line minimizations. </help>
                  <default> 100.0 </default>
                  <dtype> float </dtype>
               </biggest_step>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 6 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <old_pos units='' shape='' mode=''>
                  <help> The previous positions in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pos>
               <old_pot units='' shape='' mode=''>
                  <help> The previous potential energy in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> energy </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pot>
               <old_force units='' shape='' mode=''>
                  <help> The previous force in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_force>
               <old_direction shape='' mode=''>
                  <help> The previous direction in a CG or SD optimization. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <invhessian_bfgs shape='' mode=''>
                  <help> Approximate inverse Hessian for BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </invhessian_bfgs>
               <hessian_trm shape='' mode=''>
                  <help> Approximate Hessian for trm, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hessian_trm>
               <tr_trm units='' shape='' mode=''>
                  <help> The trust radius in trm. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </tr_trm>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
            </optimizer>
            <nstep>
               <help> The number of optimization steps. </help>
               <default> 10 </default>
               <dtype> integer </dtype>
            </nstep>
            <a0 units=''>
               <help> FCC lattice parameter  </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> length </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </a0>
            <diffusion_barrier_al units=''>
               <help> Barrier for vacancy diffusion in pure Al. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.01 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_barrier_al>
            <diffusion_prefactor_al units=''>
               <help> Prefactor for vacancy diffusion in pure Al. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> frequency </dimension>
               <default> 2.4188843e-05 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_prefactor_al>
            <diffusion_barrier_mg units=''>
               <help> Barrier for vacancy-assisted diffusion of Mg. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_barrier_mg>
            <diffusion_prefactor_mg units=''>
               <help> Prefactor for vacancy-assisted diffusion of Mg. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> frequency </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_prefactor_mg>
            <diffusion_barrier_si units=''>
               <help> Barrier for vacancy-assisted diffusion of Si. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> energy </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_barrier_si>
            <diffusion_prefactor_si units=''>
               <help> Prefactor for vacancy-assisted diffusion of Si. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> frequency </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </diffusion_prefactor_si>
            <neval>
               <help> The number of parallel force evaluators. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </neval>
            <ncell>
               <help> The number of repeat cells in each direction. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </ncell>
            <nvac>
               <help> The number of vacancies. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </nvac>
            <nsi>
               <help> The number of silicon atoms. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </nsi>
            <nmg>
               <help> The number of magnesium atoms. </help>
               <default> 4 </default>
               <dtype> integer </dtype>
            </nmg>
            <idx shape='' mode=''>
               <help> The position of the atoms on the lattice, relative to the canonical ordering. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </idx>
            <tottime units=''>
               <help> Total KMC time elapsed  </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </tottime>
            <ecache_file>
               <help> Filename for storing/loading energy cache </help>
               <default>  </default>
               <dtype> string </dtype>
            </ecache_file>
            <qcache_file>
               <help> Filename for storing/loading positions cache </help>
               <default>  </default>
               <dtype> string </dtype>
            </qcache_file>
            <max_cache_len>
               <help> Maximum cache length before oldest entry is deleted </help>
               <default> 1000 </default>
               <dtype> integer </dtype>
            </max_cache_len>
         </al6xxx_kmc>
         <planetary mode=''>
            <help> Option for planetary model calculator </help>
            <mode_help> The constrained-centroid sampling mode.  </mode_help>
            <mode_default> md </mode_default>
            <mode_options> ['md'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <thermostat mode=''>
               <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
               <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
               <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ethermo units=''>
                  <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </ethermo>
               <tau units=''>
                  <help> The friction coefficient for white noise thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tau>
               <pile_lambda>
                  <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </pile_lambda>
               <pile_centroid_t units=''>
                  <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> temperature </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </pile_centroid_t>
               <A units='' shape='' mode=''>
                  <help> The friction matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> frequency </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </A>
               <C units='' shape='' mode=''>
                  <help> The covariance matrix for GLE thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> temperature </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </C>
               <s units='' shape='' mode=''>
                  <help> Input values for the additional momenta in GLE. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> ms-momentum </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </s>
               <intau units=''>
                  <help> The inherent noise time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </intau>
               <idtau units=''>
                  <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </idtau>
               <apat units=''>
                  <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </apat>
               <flip>
                  <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                  <default> rescale </default>
                  <dtype> string </dtype>
               </flip>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
               </thermostat>
            </thermostat>
            <timestep units=''>
               <help> The time step. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> time </dimension>
               <default> 1.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </timestep>
            <nmts shape='' mode=''>
               <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </nmts>
            <nsamples>
               <help> Number of samples to accumulate for each planetary step. </help>
               <default> 0 </default>
               <dtype> integer </dtype>
            </nsamples>
            <stride>
               <help> How often the planetary calculation should actually be triggered. </help>
               <default> 1 </default>
               <dtype> integer </dtype>
            </stride>
            <nbeads>
               <help> Number of beads for centroid-constrained dynamics (default same as master trajectory) </help>
               <default> -1 </default>
               <dtype> integer </dtype>
            </nbeads>
            <screen units=''>
               <help> Screening parameter for path-integral frequency matrix. </help>
               <units_help> The units the input data is given in. </units_help>
               <dimension> length </dimension>
               <default> 0.0 </default>
               <units_default> automatic </units_default>
               <dtype> float </dtype>
               <units_dtype> string </units_dtype>
            </screen>
         </planetary>
         <motion mode=''>
            <help> A motion class that can be included as a member of a 'multi' integrator. </help>
            <mode_help> How atoms should be moved at each step in the simulatio. 'replay' means that a simulation is replayed from trajectories provided to i-PI. </mode_help>
            <mode_options> ['vibrations', 'minimize', 'replay', 'neb', 'string', 'dynamics', 'driven_dynamics', 'constrained_dynamics', 't_ramp', 'p_ramp', 'alchemy', 'atomswap', 'planetary', 'instanton', 'al-kmc', 'dummy', 'scp', 'normalmodes', 'multi'] </mode_options>
            <mode_dtype> string </mode_dtype>
            <fixcom>
               <help> This describes whether the centre of mass of the particles is fixed. </help>
               <default> True </default>
               <dtype> boolean </dtype>
            </fixcom>
            <fixatoms shape='' mode=''>
               <help> Indices of the atmoms that should be held fixed. </help>
               <shape_help> The shape of the array. </shape_help>
               <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
               <default> [ ] </default>
               <shape_default> (0,) </shape_default>
               <mode_default> manual </mode_default>
               <mode_options> ['manual', 'file'] </mode_options>
               <dtype> integer </dtype>
               <shape_dtype> tuple </shape_dtype>
               <mode_dtype> string </mode_dtype>
            </fixatoms>
            <optimizer mode=''>
               <help> Option for geometry optimization </help>
               <mode_help> The geometry optimization algorithm to be used </mode_help>
               <mode_default> lbfgs </mode_default>
               <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'lbfgs', 'damped_bfgs'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <ls_options>
                  <help> "Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search (as a fraction of the overall energy tolerance),
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
                  <tolerance units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tolerance>
                  <iter>
                     <help> Generic input value </help>
                     <default> 100 </default>
                     <dtype> integer </dtype>
                  </iter>
                  <step units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </step>
                  <adaptive>
                     <help> Generic input value </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </adaptive>
               </ls_options>
               <exit_on_convergence>
                  <help> Terminates the simulation when the convergence criteria are met. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </exit_on_convergence>
               <tolerances>
                  <help> Convergence criteria for optimization. Default values are extremely conservative. Set them to appropriate values for production runs. </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-07 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <biggest_step>
                  <help> The maximum step size for (L)-BFGS line minimizations. </help>
                  <default> 100.0 </default>
                  <dtype> float </dtype>
               </biggest_step>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 6 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <old_pos units='' shape='' mode=''>
                  <help> The previous positions in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pos>
               <old_pot units='' shape='' mode=''>
                  <help> The previous potential energy in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> energy </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pot>
               <old_force units='' shape='' mode=''>
                  <help> The previous force in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_force>
               <old_direction shape='' mode=''>
                  <help> The previous direction in a CG or SD optimization. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <invhessian_bfgs shape='' mode=''>
                  <help> Approximate inverse Hessian for BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </invhessian_bfgs>
               <hessian_trm shape='' mode=''>
                  <help> Approximate Hessian for trm, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hessian_trm>
               <tr_trm units='' shape='' mode=''>
                  <help> The trust radius in trm. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </tr_trm>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
            </optimizer>
            <neb_optimizer mode=''>
               <help> Option for NEB optimization </help>
               <mode_help> The geometry optimization algorithm to optimize NEB path </mode_help>
               <mode_default> fire </mode_default>
               <mode_options> ['bfgstrm', 'damped_bfgs', 'fire'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <tolerances>
                  <help> Tolerance criteria to stop NEB optimization.
                           If you work with DFT, do not use these defaults.
                         </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <old_coord units='' shape='' mode=''>
                  <help> The previous position in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_coord>
               <full_force units='' shape='' mode=''>
                  <help> The previous full-dimensional force in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </full_force>
               <full_pots units='' shape='' mode=''>
                  <help> Previous physical potentials of all beads. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> energy </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </full_pots>
               <old_nebpotential shape='' mode=''>
                  <help> Previous NEB potential energy, which includes spring energy. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_nebpotential>
               <old_nebgradient shape='' mode=''>
                  <help> The previous gradient including NEB spring forces. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_nebgradient>
               <old_direction shape='' mode=''>
                  <help> The previous direction. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <biggest_step units=''>
                  <help> The maximum atomic displacement in a single step
                           of optimizations within NEB procedure.
                           If requested step is larger, it will be downscaled so
                           that maximal atomic displacement won't exceed biggest_step.
                         </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.5 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </biggest_step>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <hessian_bfgs shape='' mode=''>
                  <help> Approximate Hessian for damped_BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hessian_bfgs>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 5 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <dtmax_fire>
                  <help> Maximum time interval per step for FIRE. </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </dtmax_fire>
               <v_fire shape='' mode=''>
                  <help> Current velocity for FIRE </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </v_fire>
               <alpha_fire>
                  <help> velocity mixing factor for FIRE </help>
                  <default> 0.1 </default>
                  <dtype> float </dtype>
               </alpha_fire>
               <N_down_fire>
                  <help> consecutive steps in downhill dierction for FIRE </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </N_down_fire>
               <N_up_fire>
                  <help> consecutive steps in uphill direction </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </N_up_fire>
               <dt_fire>
                  <help> time per step </help>
                  <default> 0.1 </default>
                  <dtype> float </dtype>
               </dt_fire>
               <endpoints>
                  <help> Geometry optimization of endpoints (not implemented yet) </help>
                  <optimize>
                     <help> Generic input value </help>
                     <default> False </default>
                     <dtype> boolean </dtype>
                  </optimize>
                  <algorithm>
                     <help> Generic input value </help>
                     <default> bfgs </default>
                     <dtype> string </dtype>
                  </algorithm>
               </endpoints>
               <spring>
                  <help> Uniform or variable spring constants along the elastic band </help>
                  <varsprings>
                     <help> Generic input value </help>
                     <default> False </default>
                     <dtype> boolean </dtype>
                  </varsprings>
                  <kappa>
                     <help> Generic input value </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </kappa>
                  <kappamax>
                     <help> Generic input value </help>
                     <default> 1.5 </default>
                     <dtype> float </dtype>
                  </kappamax>
                  <kappamin>
                     <help> Generic input value </help>
                     <default> 0.5 </default>
                     <dtype> float </dtype>
                  </kappamin>
               </spring>
               <tangent>
                  <help> How to calculate tangents: simple averaging from the original 1998 paper, or the improved tangent estimate from J. Chem. Phys. 113, 9978 (2000) </help>
                  <default> improved </default>
                  <options> ['plain', 'improved'] </options>
                  <dtype> string </dtype>
               </tangent>
               <stage>
                  <help> Stage of the NEB pipeline: optimization of endpoints, NEB itself, climbing image </help>
                  <default> neb </default>
                  <options> ['endpoints', 'neb', 'climb'] </options>
                  <dtype> string </dtype>
               </stage>
               <use_climb>
                  <help> Use climbing image NEB or not </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </use_climb>
               <climb_bead>
                  <help> The index of the climbing bead. </help>
                  <default> -1 </default>
                  <dtype> integer </dtype>
               </climb_bead>
            </neb_optimizer>
            <string_optimizer mode=''>
               <help> Option for String minimal-energy path optimization </help>
               <mode_help> The geometry optimization algorithm to optimize MEP string </mode_help>
               <mode_default> bfgstrm </mode_default>
               <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'damped_bfgs', 'lbfgs', 'fire', 'euler'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <tolerances>
                  <help> Tolerance criteria to stop String optimization.
                           If you work with DFT, do not use these defaults.
                         </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 1e-08 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <old_coord units='' shape='' mode=''>
                  <help> The previous position in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_coord>
               <full_force units='' shape='' mode=''>
                  <help> The previous full-dimensional force in an optimization step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </full_force>
               <full_pots units='' shape='' mode=''>
                  <help> Previous physical potentials of all beads. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> energy </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </full_pots>
               <old_stringpotential shape='' mode=''>
                  <help> Previous string potential energy. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_stringpotential>
               <old_stringgradient shape='' mode=''>
                  <help> The previous gradient of the string. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_stringgradient>
               <old_direction shape='' mode=''>
                  <help> The previous direction. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <biggest_step units=''>
                  <help> The maximum atomic displacement in a single step
                           of optimizations within String MEP procedure.
                           If requested step is larger, it will be downscaled so
                           that maximal atomic displacement won't exceed biggest_step.
                         </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.5 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </biggest_step>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <hessian_bfgs shape='' mode=''>
                  <help> Approximate Hessian for damped_BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hessian_bfgs>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 5 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <tr_trm units='' shape='' mode=''>
                  <help> Starting value for the trust radius for BFGSTRM. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default>
                     [1.]
                  </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </tr_trm>
               <dtmax_fire>
                  <help> Maximum time interval per step for FIRE. </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </dtmax_fire>
               <v_fire shape='' mode=''>
                  <help> Current velocity for FIRE </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </v_fire>
               <alpha_fire>
                  <help> velocity mixing factor for FIRE </help>
                  <default> 0.1 </default>
                  <dtype> float </dtype>
               </alpha_fire>
               <N_down_fire>
                  <help> consecutive steps in downhill dierction for FIRE </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </N_down_fire>
               <N_up_fire>
                  <help> consecutive steps in uphill direction </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </N_up_fire>
               <dt_fire>
                  <help> time per step </help>
                  <default> 0.1 </default>
                  <dtype> float </dtype>
               </dt_fire>
               <endpoints>
                  <help> Geometry optimization of endpoints (not implemented yet) </help>
                  <optimize>
                     <help> Generic input value </help>
                     <default> False </default>
                     <dtype> boolean </dtype>
                  </optimize>
                  <algorithm>
                     <help> Generic input value </help>
                     <default> bfgstrm </default>
                     <dtype> string </dtype>
                  </algorithm>
               </endpoints>
               <stage>
                  <help> Stage of the String pipeline: optimization of the endpoints, string opt., climbing image opt. </help>
                  <default> string </default>
                  <options> ['endpoints', 'string', 'climb'] </options>
                  <dtype> string </dtype>
               </stage>
               <use_climb>
                  <help> Use climbing image String MEP or not </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </use_climb>
               <climb_bead>
                  <help> The index of the climbing bead. </help>
                  <default> -1 </default>
                  <dtype> integer </dtype>
               </climb_bead>
            </string_optimizer>
            <dynamics mode='' splitting=''>
               <help> Option for (path integral) molecular dynamics </help>
               <mode_help> The ensemble that will be sampled during the simulation.
                nve: constant-energy-volume; nvt: constant-temperature-volume;
                npt: constant-temperature-pressure(isotropic); nst: constant-temperature-stress(anisotropic);
                sc: Suzuki-Chin high-order NVT; scnpt: Suzuki-Chin high-order NpT;
                nvt-cc: constrained-centroid NVT;
                eda-nve: time-dependent-field driven NVE
                  </mode_help>
               <splitting_help> The Louiville splitting used for sampling the target ensemble.  </splitting_help>
               <mode_default> nve </mode_default>
               <splitting_default> obabo </splitting_default>
               <mode_options> ['nve', 'nvt', 'npt', 'nst', 'sc', 'scnpt', 'nvt-cc', 'eda-nve'] </mode_options>
               <splitting_options> ['obabo', 'baoab'] </splitting_options>
               <mode_dtype> string </mode_dtype>
               <splitting_dtype> string </splitting_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <barostat mode=''>
                  <help> Simulates an external pressure bath. </help>
                  <mode_help> The type of barostat. 'isotropic' implements the Bussi-Zykova-Parrinello barostat [doi:10.1063/1.3073889] that isotropically scales the volume while sampling the isothermal isobaric ensemble. The implementation details are given in [doi:10.1016/j.cpc.2013.10.027]. 'sc-isotropic' implements the same for Suzuki-Chin path integral molecular dynamics [10.1021/acs.jctc.8b01297]. This barostat is suitable for simulating liquids. 'flexible' implements the path integral version of the Martyna-Tuckerman-Tobias-Klein barostat which incorporates full cell fluctuations while sampling the isothermal isobaric ensemble [doi:10.1063/1.478193]. This is suitable for anisotropic systems such as molecular solids. 'anisotropic' implements the Raiteri-Gale-Bussi barostat which enables cell fluctuations at constant external stress [10.1088/0953-8984/23/33/334213]. It is suitable for simulating solids at given external (non-diagonal) stresses and requires specifying a reference cell for estimating strain. Note that this ensemble is valid only within the elastic limit of small strains. For diagonal stresses (or external pressures) the 'flexible' and the 'anisotropic' modes should give very similar results. 'dummy' barostat does not do anything. </mode_help>
                  <mode_default> dummy </mode_default>
                  <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <thermostat mode=''>
                     <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                     <thermostat mode=''>
                        <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                        <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                        <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                        <mode_dtype> string </mode_dtype>
                        <ethermo units=''>
                           <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> energy </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </ethermo>
                        <tau units=''>
                           <help> The friction coefficient for white noise thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </tau>
                        <pile_lambda>
                           <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                           <default> 1.0 </default>
                           <dtype> float </dtype>
                        </pile_lambda>
                        <pile_centroid_t units=''>
                           <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> temperature </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </pile_centroid_t>
                        <A units='' shape='' mode=''>
                           <help> The friction matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> frequency </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </A>
                        <C units='' shape='' mode=''>
                           <help> The covariance matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> temperature </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </C>
                        <s units='' shape='' mode=''>
                           <help> Input values for the additional momenta in GLE. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> ms-momentum </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </s>
                        <intau units=''>
                           <help> The inherent noise time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </intau>
                        <idtau units=''>
                           <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </idtau>
                        <apat units=''>
                           <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </apat>
                        <flip>
                           <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                           <default> rescale </default>
                           <dtype> string </dtype>
                        </flip>
                     </thermostat>
                  </thermostat>
                  <tau units=''>
                     <help> The time constant associated with the dynamics of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 1.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <p units='' shape='' mode=''>
                     <help> Momentum (or momenta) of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </p>
                  <h0 units='' shape='' mode=''>
                     <help> Reference cell for Parrinello-Rahman-like barostats. Should be roughly equal to the mean size of the cell averaged over the trajectory. Sampling might be inaccurate if the difference is too large. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default>
                        [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                     </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </h0>
                  <hfix shape='' mode=''>
                     <help> A list of the cell entries that should be held fixed (xx, yy, zz, xy, xz, yz). 'offdiagonal' is an alias for xy, xz, yz. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> string </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </hfix>
               </barostat>
               <timestep units=''>
                  <help> The time step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </timestep>
               <nmts shape='' mode=''>
                  <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </nmts>
            </dynamics>
            <driven_dynamics mode='' splitting=''>
               <help> Option for driven molecular dynamics </help>
               <mode_help> The ensemble that will be sampled during the simulation.
                nve: constant-energy-volume; nvt: constant-temperature-volume;
                npt: constant-temperature-pressure(isotropic); nst: constant-temperature-stress(anisotropic);
                sc: Suzuki-Chin high-order NVT; scnpt: Suzuki-Chin high-order NpT;
                nvt-cc: constrained-centroid NVT;
                eda-nve: time-dependent-field driven NVE
                  </mode_help>
               <splitting_help> The Louiville splitting used for sampling the target ensemble.  </splitting_help>
               <mode_default> nve </mode_default>
               <splitting_default> obabo </splitting_default>
               <mode_options> ['nve', 'nvt', 'npt', 'nst', 'sc', 'scnpt', 'nvt-cc', 'eda-nve'] </mode_options>
               <splitting_options> ['obabo', 'baoab'] </splitting_options>
               <mode_dtype> string </mode_dtype>
               <splitting_dtype> string </splitting_dtype>
               <efield>
                  <help> The external electric field parameters:plane-wave parameters (intensity/amplitude, angular frequency, and phase) and gaussian envelope function parameters (peak time/mean of the gaussian, and pulse duration/standard deviation of the gaussian) </help>
                  <amp units='' shape='' mode=''>
                     <help> The amplitude of the external electric field (in cartesian coordinates) </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> electric-field </dimension>
                     <default>
                        [0. 0. 0.]
                     </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </amp>
                  <freq units=''>
                     <help> The pulsation of the external electric field </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> frequency </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </freq>
                  <phase units=''>
                     <help> The phase of the external electric field (in rad) </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> number </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </phase>
                  <peak units=''>
                     <help> The time when the external electric field gets its maximum value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </peak>
                  <sigma units=''>
                     <help> The standard deviations (time) of the gaussian envelope function of the external electric field </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> inf </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </sigma>
               </efield>
               <bec units='' shape='' mode=''>
                  <help> The Born Effective Charges tensors (cartesian coordinates) </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'driver', then the array is computed on the fly. If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> number </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> none </mode_default>
                  <mode_options> ['driver', 'manual', 'file', 'none'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </bec>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <barostat mode=''>
                  <help> Simulates an external pressure bath. </help>
                  <mode_help> The type of barostat. 'isotropic' implements the Bussi-Zykova-Parrinello barostat [doi:10.1063/1.3073889] that isotropically scales the volume while sampling the isothermal isobaric ensemble. The implementation details are given in [doi:10.1016/j.cpc.2013.10.027]. 'sc-isotropic' implements the same for Suzuki-Chin path integral molecular dynamics [10.1021/acs.jctc.8b01297]. This barostat is suitable for simulating liquids. 'flexible' implements the path integral version of the Martyna-Tuckerman-Tobias-Klein barostat which incorporates full cell fluctuations while sampling the isothermal isobaric ensemble [doi:10.1063/1.478193]. This is suitable for anisotropic systems such as molecular solids. 'anisotropic' implements the Raiteri-Gale-Bussi barostat which enables cell fluctuations at constant external stress [10.1088/0953-8984/23/33/334213]. It is suitable for simulating solids at given external (non-diagonal) stresses and requires specifying a reference cell for estimating strain. Note that this ensemble is valid only within the elastic limit of small strains. For diagonal stresses (or external pressures) the 'flexible' and the 'anisotropic' modes should give very similar results. 'dummy' barostat does not do anything. </mode_help>
                  <mode_default> dummy </mode_default>
                  <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <thermostat mode=''>
                     <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                     <thermostat mode=''>
                        <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                        <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                        <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                        <mode_dtype> string </mode_dtype>
                        <ethermo units=''>
                           <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> energy </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </ethermo>
                        <tau units=''>
                           <help> The friction coefficient for white noise thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </tau>
                        <pile_lambda>
                           <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                           <default> 1.0 </default>
                           <dtype> float </dtype>
                        </pile_lambda>
                        <pile_centroid_t units=''>
                           <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> temperature </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </pile_centroid_t>
                        <A units='' shape='' mode=''>
                           <help> The friction matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> frequency </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </A>
                        <C units='' shape='' mode=''>
                           <help> The covariance matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> temperature </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </C>
                        <s units='' shape='' mode=''>
                           <help> Input values for the additional momenta in GLE. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> ms-momentum </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </s>
                        <intau units=''>
                           <help> The inherent noise time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </intau>
                        <idtau units=''>
                           <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </idtau>
                        <apat units=''>
                           <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </apat>
                        <flip>
                           <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                           <default> rescale </default>
                           <dtype> string </dtype>
                        </flip>
                     </thermostat>
                  </thermostat>
                  <tau units=''>
                     <help> The time constant associated with the dynamics of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 1.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <p units='' shape='' mode=''>
                     <help> Momentum (or momenta) of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </p>
                  <h0 units='' shape='' mode=''>
                     <help> Reference cell for Parrinello-Rahman-like barostats. Should be roughly equal to the mean size of the cell averaged over the trajectory. Sampling might be inaccurate if the difference is too large. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default>
                        [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                     </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </h0>
                  <hfix shape='' mode=''>
                     <help> A list of the cell entries that should be held fixed (xx, yy, zz, xy, xz, yz). 'offdiagonal' is an alias for xy, xz, yz. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> string </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </hfix>
               </barostat>
               <timestep units=''>
                  <help> The time step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </timestep>
               <nmts shape='' mode=''>
                  <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </nmts>
            </driven_dynamics>
            <constrained_dynamics mode='' splitting=''>
               <help> Option for constrained classical molecular dynamics </help>
               <mode_help> The ensemble that will be sampled during the simulation.  </mode_help>
               <splitting_help> The integrator used for sampling the target ensemble.  </splitting_help>
               <mode_default> nve </mode_default>
               <splitting_default> baoab </splitting_default>
               <mode_options> ['nve', 'nvt'] </mode_options>
               <splitting_options> ['obabo', 'baoab'] </splitting_options>
               <mode_dtype> string </mode_dtype>
               <splitting_dtype> string </splitting_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <barostat mode=''>
                  <help> Simulates an external pressure bath. </help>
                  <mode_help> The type of barostat. 'isotropic' implements the Bussi-Zykova-Parrinello barostat [doi:10.1063/1.3073889] that isotropically scales the volume while sampling the isothermal isobaric ensemble. The implementation details are given in [doi:10.1016/j.cpc.2013.10.027]. 'sc-isotropic' implements the same for Suzuki-Chin path integral molecular dynamics [10.1021/acs.jctc.8b01297]. This barostat is suitable for simulating liquids. 'flexible' implements the path integral version of the Martyna-Tuckerman-Tobias-Klein barostat which incorporates full cell fluctuations while sampling the isothermal isobaric ensemble [doi:10.1063/1.478193]. This is suitable for anisotropic systems such as molecular solids. 'anisotropic' implements the Raiteri-Gale-Bussi barostat which enables cell fluctuations at constant external stress [10.1088/0953-8984/23/33/334213]. It is suitable for simulating solids at given external (non-diagonal) stresses and requires specifying a reference cell for estimating strain. Note that this ensemble is valid only within the elastic limit of small strains. For diagonal stresses (or external pressures) the 'flexible' and the 'anisotropic' modes should give very similar results. 'dummy' barostat does not do anything. </mode_help>
                  <mode_default> dummy </mode_default>
                  <mode_options> ['dummy', 'isotropic', 'flexible', 'anisotropic', 'sc-isotropic'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <thermostat mode=''>
                     <help> The thermostat for the cell. Keeps the cell velocity distribution at the correct temperature. Note that the 'pile_l', 'pile_g', 'nm_gle' and 'nm_gle_g' options will not work for this thermostat. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                     <thermostat mode=''>
                        <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                        <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                        <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                        <mode_dtype> string </mode_dtype>
                        <ethermo units=''>
                           <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> energy </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </ethermo>
                        <tau units=''>
                           <help> The friction coefficient for white noise thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </tau>
                        <pile_lambda>
                           <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                           <default> 1.0 </default>
                           <dtype> float </dtype>
                        </pile_lambda>
                        <pile_centroid_t units=''>
                           <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> temperature </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </pile_centroid_t>
                        <A units='' shape='' mode=''>
                           <help> The friction matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> frequency </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </A>
                        <C units='' shape='' mode=''>
                           <help> The covariance matrix for GLE thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> temperature </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </C>
                        <s units='' shape='' mode=''>
                           <help> Input values for the additional momenta in GLE. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <shape_help> The shape of the array. </shape_help>
                           <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                           <dimension> ms-momentum </dimension>
                           <default> [ ] </default>
                           <units_default> automatic </units_default>
                           <shape_default> (0,) </shape_default>
                           <mode_default> manual </mode_default>
                           <mode_options> ['manual', 'file'] </mode_options>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                           <shape_dtype> tuple </shape_dtype>
                           <mode_dtype> string </mode_dtype>
                        </s>
                        <intau units=''>
                           <help> The inherent noise time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </intau>
                        <idtau units=''>
                           <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </idtau>
                        <apat units=''>
                           <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                           <units_help> The units the input data is given in. </units_help>
                           <dimension> time </dimension>
                           <default> 0.0 </default>
                           <units_default> automatic </units_default>
                           <dtype> float </dtype>
                           <units_dtype> string </units_dtype>
                        </apat>
                        <flip>
                           <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                           <default> rescale </default>
                           <dtype> string </dtype>
                        </flip>
                     </thermostat>
                  </thermostat>
                  <tau units=''>
                     <help> The time constant associated with the dynamics of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 1.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <p units='' shape='' mode=''>
                     <help> Momentum (or momenta) of the piston. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </p>
                  <h0 units='' shape='' mode=''>
                     <help> Reference cell for Parrinello-Rahman-like barostats. Should be roughly equal to the mean size of the cell averaged over the trajectory. Sampling might be inaccurate if the difference is too large. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default>
                        [0. 0. 0. 0. 0. 0. 0. 0. 0.]
                     </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </h0>
                  <hfix shape='' mode=''>
                     <help> A list of the cell entries that should be held fixed (xx, yy, zz, xy, xz, yz). 'offdiagonal' is an alias for xy, xz, yz. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> string </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </hfix>
               </barostat>
               <timestep units=''>
                  <help> The time step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </timestep>
               <nmts shape='' mode=''>
                  <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </nmts>
               <nsteps_o>
                  <help> The number of sub steps used in the evolution of the thermostat (used in function step_Oc). Relevant only for GLE thermostats </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </nsteps_o>
               <nsteps_geo>
                  <help> The number of sub steps used in the evolution of the geodesic flow (used in function step_Ag). </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </nsteps_geo>
               <csolver>
                  <help> Define a numerical method for computing the projection operators associated with the constraint. </help>
                  <tolerance>
                     <help> Tolerance value used in the Quasi-Newton iteration scheme. </help>
                     <default> 0.0001 </default>
                     <dtype> float </dtype>
                  </tolerance>
                  <maxit>
                     <help> Maximum number of steps used in the Quasi-Newton iteration scheme. </help>
                     <default> 1000 </default>
                     <dtype> integer </dtype>
                  </maxit>
                  <norm_order>
                     <help> Order of norm used to determine termination of the Quasi-newton iteration. </help>
                     <default> 2 </default>
                     <dtype> integer </dtype>
                  </norm_order>
               </csolver>
               <constraint mode=''>
                  <help> Define a constraint to be applied onto atoms </help>
                  <mode_help> The type of constraint.  </mode_help>
                  <mode_default> distance </mode_default>
                  <mode_options> ['distance', 'angle', 'eckart', 'multi', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <atoms shape='' mode=''>
                     <help> List of atoms indices that are to be constrained. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> integer </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </atoms>
                  <values units='' shape='' mode=''>
                     <help> List of constraint lengths. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </values>
                  <constraint mode=''>
                     <help> One or more constraints that have to be considered coupled </help>
                     <mode_help> The type of constraint.  </mode_help>
                     <mode_default> distance </mode_default>
                     <mode_options> ['distance', 'angle', 'eckart', 'multi', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <atoms shape='' mode=''>
                        <help> List of atoms indices that are to be constrained. </help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <default> [ ] </default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> integer </dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </atoms>
                     <values units='' shape='' mode=''>
                        <help> List of constraint lengths. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> length </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </values>
                  </constraint>
               </constraint>
            </constrained_dynamics>
            <file mode='' bead='' cell_units=''>
               <help> This describes the location to read a trajectory file from. Replay syntax allows using some POSIX wildcards in the filename of trajectory files. If symbols ?*[] are found in a filename, the code expects to find exactly Nbeads files that match the provided pattern. Bead indices will be read from the files, and the files will be ordered ascendingly by their bead indices. Wildcarded files are expected to be in the folder where the simulation runs. </help>
               <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 
        'chk' stands for initialization from a checkpoint file. 'ase' is to read a file with the Atomic Simulation Environment </mode_help>
               <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
               <cell_units_help> The units for the cell dimensions. </cell_units_help>
               <default>  </default>
               <mode_default> chk </mode_default>
               <bead_default> -1 </bead_default>
               <cell_units_default> automatic </cell_units_default>
               <mode_options> ['xyz', 'pdb', 'chk', 'ase'] </mode_options>
               <dtype> string </dtype>
               <mode_dtype> string </mode_dtype>
               <bead_dtype> integer </bead_dtype>
               <cell_units_dtype> string </cell_units_dtype>
            </file>
            <vibrations mode=''>
               <help> Option for phonon computation </help>
               <mode_help> The algorithm to be used: finite differences (fd), normal modes finite differences (nmfd), and energy-scaled normal mode finite differences (enmfd). </mode_help>
               <mode_default> fd </mode_default>
               <mode_options> ['fd', 'nmfd', 'enmfd'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <pos_shift>
                  <help> The finite displacement in position used to compute derivative of force. </help>
                  <default> 0.01 </default>
                  <dtype> float </dtype>
               </pos_shift>
               <energy_shift>
                  <help> The finite displacement in energy used to compute derivative of force. </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </energy_shift>
               <output_shift>
                  <help> Shift by the dynamical matrix diagonally before outputting. </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </output_shift>
               <prefix>
                  <help> Prefix of the output files. </help>
                  <default> phonons </default>
                  <dtype> string </dtype>
               </prefix>
               <asr>
                  <help> Removes the zero frequency vibrational modes depending on the symmerty of the system. </help>
                  <default> none </default>
                  <options> ['none', 'poly', 'lin', 'crystal'] </options>
                  <dtype> string </dtype>
               </asr>
               <dynmat shape='' mode=''>
                  <help> Portion of the dynamical matrix known up to now. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </dynmat>
               <refdynmat shape='' mode=''>
                  <help> Portion of the refined dynamical matrix known up to now. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </refdynmat>
            </vibrations>
            <normalmodes mode=''>
               <help> Option for solving the vibrational Schroedinger's equations in normal mode coordinates. </help>
               <mode_help> The algorithm to be used: independent mode framework (imf) and vibrational self consistent field (vscf). </mode_help>
               <mode_default> imf </mode_default>
               <mode_options> ['imf', 'vscf'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <prefix>
                  <help> Prefix of the output files. </help>
                  <default>  </default>
                  <dtype> string </dtype>
               </prefix>
               <asr>
                  <help> Removes the zero frequency vibrational modes depending on the symmetry of the system for general polyatomic molecules, and periodic crystal structures. </help>
                  <default> none </default>
                  <options> ['none', 'poly', 'crystal'] </options>
                  <dtype> string </dtype>
               </asr>
               <dynmat shape='' mode=''>
                  <help> Portion of the dynamical matrix known to the current point in the calculation. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </dynmat>
               <nprim>
                  <help> Number of primitive unit cells in the simulation cell. </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </nprim>
               <fnmrms>
                  <help> Fraction of harmonic RMS displacement used to sample along normal mode. </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </fnmrms>
               <nevib>
                  <help> Multiple of harm vibr energy up to which BO surface is sampled. </help>
                  <default> 25.0 </default>
                  <dtype> float </dtype>
               </nevib>
               <nint>
                  <help> Integration points for Hamiltonian matrix elements. </help>
                  <default> 101 </default>
                  <dtype> integer </dtype>
               </nint>
               <pair_range shape='' mode=''>
                  <help> The range of pair combinations of normal modes to be considered. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </pair_range>
               <nbasis>
                  <help> Number of SHO states used as basis for anharmonic wvfn. </help>
                  <default> 10 </default>
                  <dtype> integer </dtype>
               </nbasis>
               <athresh units=''>
                  <help> Convergence threshold for absolute error in vibr free energy per degree of freedom. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 3.6749322e-06 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </athresh>
               <ethresh>
                  <help> Convergence thresh for fractional error in vibr free energy. </help>
                  <default> 0.01 </default>
                  <dtype> float </dtype>
               </ethresh>
               <alpha>
                  <help> The fraction of mean field potential to mix with the result of the previous SCF iteration. </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </alpha>
               <nkbt>
                  <help> Threshold for (e - e_gs)/(kB T) of vibr state to be incl in the VSCF and partition function. </help>
                  <default> 4.0 </default>
                  <dtype> float </dtype>
               </nkbt>
               <nexc>
                  <help> Minimum number of excited n-body states to calculate (also in MP2 correction). </help>
                  <default> 5 </default>
                  <dtype> integer </dtype>
               </nexc>
               <mptwo>
                  <help> Flag determining whether MP2 correction is calculated. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </mptwo>
               <solve>
                  <help> Flag determining whether the VSCF mean field Schroedinger's equation is solved. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </solve>
               <grid>
                  <help> Flag determining whether the coupling potential is gridded or not. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </grid>
               <print_mftpot>
                  <help> Flag determining whether MFT potentials are printed to file. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </print_mftpot>
               <print_1b_map>
                  <help> Flag determining whether the independent mode potentials are printed to file. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </print_1b_map>
               <print_2b_map>
                  <help> Flag determining whether the two body mapped coupling potentials are printed to file. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </print_2b_map>
               <print_vib_density>
                  <help> Flag determining whether the vibrational density (psi**2) are printed to file. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </print_vib_density>
               <threebody>
                  <help> Flag determining whether three-mode coupling terms are accounted for. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </threebody>
               <nparallel>
                  <help> The number of forces evaluations per i-PI step. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </nparallel>
            </normalmodes>
            <scp mode=''>
               <help> Option for self consistent phonons computation </help>
               <mode_help> The statistics to be used in the calculation of the free energy. Quantum (qn) or classical (cl) Boltzmann statistics. </mode_help>
               <mode_default> qn </mode_default>
               <mode_options> ['qn', 'cl'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <prefix>
                  <help> Prefix of the output files. </help>
                  <default>  </default>
                  <dtype> string </dtype>
               </prefix>
               <asr>
                  <help> The method used to project out zero modes coming from continuous symmetries: crystal removes the three translational modes; molecule removes the three rotational modes in addition to the translational ones. none keeps all the modes. </help>
                  <default> none </default>
                  <options> ['none', 'crystal', 'poly'] </options>
                  <dtype> string </dtype>
               </asr>
               <random_type>
                  <help> Chooses the type of random numbers. </help>
                  <default> pseudo </default>
                  <options> ['sobol', 'pseudo', 'file'] </options>
                  <dtype> string </dtype>
               </random_type>
               <displace_mode>
                  <help> The type of optimisation strategy for obtaining the mean position. sd stands for a steepest descent algorithm. ik stands for a Newton-Raphson scheme that requires the inverse of the force constant matrix iK. nmik stands for a Newton-Raphson scheme that only displaces along normal modes directions with statistically significant forces. rnmik same as nmik but performs several optimization steps using a reweighted sampling. </help>
                  <default> nmik </default>
                  <options> ['ik', 'sd', 'nmik', 'rnmik'] </options>
                  <dtype> string </dtype>
               </displace_mode>
               <dynmat shape='' mode=''>
                  <help> The dynamical matrix of the trial Hamiltonian. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </dynmat>
               <max_steps>
                  <help> Maximum number of Monte carlo steps per SCP iteration. </help>
                  <dtype> integer </dtype>
               </max_steps>
               <max_iter>
                  <help> Maximum number of SCP iterations. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </max_iter>
               <tau>
                  <help> Step size along the gradient for the sd displace_mode </help>
                  <default> 1.0 </default>
                  <dtype> float </dtype>
               </tau>
               <wthreshold>
                  <help> Threshold on minimum Boltzmann weights before more statistics must be accumulated. </help>
                  <default> 0.9 </default>
                  <dtype> float </dtype>
               </wthreshold>
               <precheck>
                  <help> Flag for checking statistical significance of forces before optimisation of mean position. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </precheck>
               <checkweights>
                  <help> Flag for checking Boltzmann weights for whether more statistics are required. </help>
                  <default> True </default>
                  <dtype> boolean </dtype>
               </checkweights>
               <chop>
                  <help> Threshold below which frequencies are set to zero. </help>
                  <default> 1e-09 </default>
                  <dtype> float </dtype>
               </chop>
               <nparallel>
                  <help> The number of Monte Carlo forces to be evaluated (in parallel) per i-PI step. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </nparallel>
               <batch_weight_exponent>
                  <help> The exponent used to suppress low batch weights. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </batch_weight_exponent>
            </scp>
            <alchemy mode=''>
               <help> Option for alchemical exchanges </help>
               <mode_help>   </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <names shape='' mode=''>
                  <help> The names of the atoms to be to exchanged, in the format [name1, name2, ... ]. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> string </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </names>
               <nxc>
                  <help> The average number of exchanges per step to be attempted  </help>
                  <default> 1 </default>
                  <dtype> float </dtype>
               </nxc>
               <ealc>
                  <help> The contribution to the conserved quantity for the alchemical exchanger </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </ealc>
            </alchemy>
            <atomswap mode=''>
               <help> Option for Monte Carlo atom swap </help>
               <mode_help> Dummy attribute, does nothing. </mode_help>
               <mode_default> dummy </mode_default>
               <mode_options> ['dummy'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <names shape='' mode=''>
                  <help> The names of the atoms to be to exchanged, in the format [name1, name2, ... ]. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> string </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </names>
               <nxc>
                  <help> The average number of exchanges per step to be attempted  </help>
                  <default> 1 </default>
                  <dtype> float </dtype>
               </nxc>
               <ealc>
                  <help> The contribution to the conserved quantity for the atom swapper </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </ealc>
            </atomswap>
            <t_ramp>
               <help> Option for temperature ramp </help>
               <t_start units=''>
                  <help> Initial temperature </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </t_start>
               <t_end units=''>
                  <help> Final temperature </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </t_end>
               <logscale>
                  <help> Change temperature on a logarihthmic scale. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </logscale>
               <total_steps>
                  <help> Total number of steps for the ramp </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </total_steps>
               <current_step>
                  <help> Current step along the ramp </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </current_step>
            </t_ramp>
            <p_ramp>
               <help> Option for pressure ramp </help>
               <p_start units=''>
                  <help> Initial pressure </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> pressure </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </p_start>
               <p_end units=''>
                  <help> Final pressure </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> pressure </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </p_end>
               <logscale>
                  <help> Change pressure on a logarihthmic scale. </help>
                  <default> False </default>
                  <dtype> boolean </dtype>
               </logscale>
               <total_steps>
                  <help> Total number of steps for the ramp </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </total_steps>
               <current_step>
                  <help> Current step along the ramp </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </current_step>
            </p_ramp>
            <instanton mode=''>
               <help> Option for Instanton optimization </help>
               <mode_help> Defines whether it is an instanton rate or instanton tunneling splitting calculaion </mode_help>
               <mode_default> rate </mode_default>
               <mode_options> ['rate', 'splitting'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <tolerances>
                  <help> Convergence criteria for optimization. </help>
                  <energy units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 1e-05 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </energy>
                  <force units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> force </dimension>
                     <default> 0.0001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </force>
                  <position units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> length </dimension>
                     <default> 0.001 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </position>
               </tolerances>
               <biggest_step>
                  <help> The maximum step size during the optimization. </help>
                  <default> 0.4 </default>
                  <dtype> float </dtype>
               </biggest_step>
               <old_pos units='' shape='' mode=''>
                  <help> The previous step positions during the optimization.  </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> length </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pos>
               <old_pot units='' shape='' mode=''>
                  <help> The previous step potential energy during the optimization </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> energy </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_pot>
               <old_force units='' shape='' mode=''>
                  <help> The previous step force during the optimization </help>
                  <units_help> The units the input data is given in. </units_help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <dimension> force </dimension>
                  <default> [ ] </default>
                  <units_default> automatic </units_default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_force>
               <opt>
                  <help> The geometry optimization algorithm to be used.
                                            For small system sizes nichols is recomended. Lanczos is tailored for big bigger than nbeads*natoms >~38*64.
                                            NR works in both cases given that the initial guess is close to the optimized geometry.
                                            Finally lbfgs is used for tunneling splitting calculations.  </help>
                  <default> None </default>
                  <options> ['nichols', 'NR', 'lbfgs', 'lanczos', 'None'] </options>
                  <dtype> string </dtype>
               </opt>
               <max_e units=''>
                  <help> Evaluate the forces in a reduced ring polymer such that the potential energy between consecutive replicas is smaller that the provided value. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </max_e>
               <max_ms>
                  <help> Evaluate the forces in a reduced ring polymer such that that mass-scaled distance in a.u. between consecutive replicas is  smaller that the provided value. </help>
                  <default> 0.0 </default>
                  <dtype> float </dtype>
               </max_ms>
               <discretization shape='' mode=''>
                  <help> Allows to specified non uniform time discretization as proposed in J. Chem. Phys. 134, 184107 (2011) </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </discretization>
               <alt_out>
                  <help> Alternative output:Prints different formatting of outputs for geometry, hessian and bead potential energies.
                                               All quantities are also accessible from typical i-pi output infrastructure.
                                               Default to 1, which prints every step. -1 will suppress the output (except the last one).
                                               Any other positive number will set the frequency (in steps) with which the quantities are
                                               written to file.
                                               The instanton geometry is printed in xyz format and the distances are in angrstroms
                                               The hessian is printed in one line with the following format:
                                               h1_1,h2_1,...,hN_1,   h2_2,h2_2,hN_2,   ....   ,h1_d,h2_d,...,hN_d.
                                               Where N represents the total number of replicas, d the number of dimension of each replica (3*n_atoms) and
                                               hi_j means the row j of the physical hessian corresponding to the replica i.
                                               The physical hessian uses a convention according to the positions convention used in  i-pi.
                                               Example of 2 particles, the first two rows of the physical hessian reads:
                                               'H_x1_x1, H_x1_y1, H_x1_z1, H_x1_x2, H_x1_y2,H_x1_z2'
                                               'H_x2_x1, H_x2_y1, H_x2_z1, H_x2_x2, H_x2_y2,H_x2_z2'  </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </alt_out>
               <prefix>
                  <help> Prefix of the output files. </help>
                  <default> instanton </default>
                  <dtype> string </dtype>
               </prefix>
               <delta>
                  <help> Initial stretch amplitude. </help>
                  <default> 0.1 </default>
                  <dtype> float </dtype>
               </delta>
               <hessian_init>
                  <help> How to initialize the hessian if it is not fully provided. </help>
                  <default> false </default>
                  <options> ['true', 'false'] </options>
                  <dtype> string </dtype>
               </hessian_init>
               <hessian shape='' mode=''>
                  <help> (Approximate) Hessian. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </hessian>
               <hessian_update>
                  <help> How to update the hessian after each step. </help>
                  <default> powell </default>
                  <options> ['powell', 'recompute'] </options>
                  <dtype> string </dtype>
               </hessian_update>
               <hessian_asr>
                  <help> Removes the zero frequency vibrational modes depending on the symmetry of the system. </help>
                  <default> none </default>
                  <options> ['none', 'poly', 'crystal'] </options>
                  <dtype> string </dtype>
               </hessian_asr>
               <qlist_lbfgs shape='' mode=''>
                  <help> List of previous position differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </qlist_lbfgs>
               <glist_lbfgs shape='' mode=''>
                  <help> List of previous gradient differences for L-BFGS, if known. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </glist_lbfgs>
               <old_direction shape='' mode=''>
                  <help> The previous direction in a CG or SD optimization. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> float </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </old_direction>
               <scale_lbfgs>
                  <help> Scale choice for the initial hessian.
                                                       0 identity.
                                                       1 Use first member of position/gradient list.
                                                       2 Use last  member of position/gradient list. </help>
                  <default> 2 </default>
                  <dtype> integer </dtype>
               </scale_lbfgs>
               <corrections_lbfgs>
                  <help> The number of past vectors to store for L-BFGS. </help>
                  <default> 20 </default>
                  <dtype> integer </dtype>
               </corrections_lbfgs>
               <ls_options>
                  <help> Options for line search methods. Includes:
                                  tolerance: stopping tolerance for the search,
                                  iter: the maximum number of iterations,
                                  step: initial step for bracketing,
                                  adaptive: whether to update initial step.
                                   </help>
                  <tolerance units=''>
                     <help> Generic input value </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.2 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tolerance>
                  <iter>
                     <help> Generic input value </help>
                     <default> 100 </default>
                     <dtype> integer </dtype>
                  </iter>
               </ls_options>
               <energy_shift units=''>
                  <help> Set the zero of energy. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </energy_shift>
               <hessian_final>
                  <help> Decide if we are going to compute the final big-hessian by finite difference. </help>
                  <default> false </default>
                  <options> ['false', 'true'] </options>
                  <dtype> string </dtype>
               </hessian_final>
            </instanton>
            <al6xxx_kmc mode=''>
               <help> Option for Al-6xxx KMC </help>
               <mode_help> The KMC algorithm to be used </mode_help>
               <mode_default> rfkmc </mode_default>
               <mode_options> ['rfkmc'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <optimizer mode=''>
                  <help> Option for geometry optimization step </help>
                  <mode_help> The geometry optimization algorithm to be used </mode_help>
                  <mode_default> lbfgs </mode_default>
                  <mode_options> ['sd', 'cg', 'bfgs', 'bfgstrm', 'lbfgs', 'damped_bfgs'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ls_options>
                     <help> "Options for line search methods. Includes:
                              tolerance: stopping tolerance for the search (as a fraction of the overall energy tolerance),
                              iter: the maximum number of iterations,
                              step: initial step for bracketing,
                              adaptive: whether to update initial step.
                               </help>
                     <tolerance units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0001 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tolerance>
                     <iter>
                        <help> Generic input value </help>
                        <default> 100 </default>
                        <dtype> integer </dtype>
                     </iter>
                     <step units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> length </dimension>
                        <default> 0.001 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </step>
                     <adaptive>
                        <help> Generic input value </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </adaptive>
                  </ls_options>
                  <exit_on_convergence>
                     <help> Terminates the simulation when the convergence criteria are met. </help>
                     <default> True </default>
                     <dtype> boolean </dtype>
                  </exit_on_convergence>
                  <tolerances>
                     <help> Convergence criteria for optimization. Default values are extremely conservative. Set them to appropriate values for production runs. </help>
                     <energy units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 1e-07 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </energy>
                     <force units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> force </dimension>
                        <default> 0.0001 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </force>
                     <position units=''>
                        <help> Generic input value </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> length </dimension>
                        <default> 0.001 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </position>
                  </tolerances>
                  <biggest_step>
                     <help> The maximum step size for (L)-BFGS line minimizations. </help>
                     <default> 100.0 </default>
                     <dtype> float </dtype>
                  </biggest_step>
                  <scale_lbfgs>
                     <help> Scale choice for the initial hessian.
                                            0 identity.
                                            1 Use first member of position/gradient list.
                                            2 Use last  member of position/gradient list. </help>
                     <default> 2 </default>
                     <dtype> integer </dtype>
                  </scale_lbfgs>
                  <corrections_lbfgs>
                     <help> The number of past vectors to store for L-BFGS. </help>
                     <default> 6 </default>
                     <dtype> integer </dtype>
                  </corrections_lbfgs>
                  <old_pos units='' shape='' mode=''>
                     <help> The previous positions in an optimization step. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </old_pos>
                  <old_pot units='' shape='' mode=''>
                     <help> The previous potential energy in an optimization step. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> energy </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </old_pot>
                  <old_force units='' shape='' mode=''>
                     <help> The previous force in an optimization step. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> force </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </old_force>
                  <old_direction shape='' mode=''>
                     <help> The previous direction in a CG or SD optimization. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </old_direction>
                  <invhessian_bfgs shape='' mode=''>
                     <help> Approximate inverse Hessian for BFGS, if known. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </invhessian_bfgs>
                  <hessian_trm shape='' mode=''>
                     <help> Approximate Hessian for trm, if known. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </hessian_trm>
                  <tr_trm units='' shape='' mode=''>
                     <help> The trust radius in trm. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> length </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </tr_trm>
                  <qlist_lbfgs shape='' mode=''>
                     <help> List of previous position differences for L-BFGS, if known. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </qlist_lbfgs>
                  <glist_lbfgs shape='' mode=''>
                     <help> List of previous gradient differences for L-BFGS, if known. </help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <default> [ ] </default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </glist_lbfgs>
               </optimizer>
               <nstep>
                  <help> The number of optimization steps. </help>
                  <default> 10 </default>
                  <dtype> integer </dtype>
               </nstep>
               <a0 units=''>
                  <help> FCC lattice parameter  </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </a0>
               <diffusion_barrier_al units=''>
                  <help> Barrier for vacancy diffusion in pure Al. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.01 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_barrier_al>
               <diffusion_prefactor_al units=''>
                  <help> Prefactor for vacancy diffusion in pure Al. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> frequency </dimension>
                  <default> 2.4188843e-05 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_prefactor_al>
               <diffusion_barrier_mg units=''>
                  <help> Barrier for vacancy-assisted diffusion of Mg. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_barrier_mg>
               <diffusion_prefactor_mg units=''>
                  <help> Prefactor for vacancy-assisted diffusion of Mg. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> frequency </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_prefactor_mg>
               <diffusion_barrier_si units=''>
                  <help> Barrier for vacancy-assisted diffusion of Si. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> energy </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_barrier_si>
               <diffusion_prefactor_si units=''>
                  <help> Prefactor for vacancy-assisted diffusion of Si. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> frequency </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </diffusion_prefactor_si>
               <neval>
                  <help> The number of parallel force evaluators. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </neval>
               <ncell>
                  <help> The number of repeat cells in each direction. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </ncell>
               <nvac>
                  <help> The number of vacancies. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </nvac>
               <nsi>
                  <help> The number of silicon atoms. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </nsi>
               <nmg>
                  <help> The number of magnesium atoms. </help>
                  <default> 4 </default>
                  <dtype> integer </dtype>
               </nmg>
               <idx shape='' mode=''>
                  <help> The position of the atoms on the lattice, relative to the canonical ordering. </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </idx>
               <tottime units=''>
                  <help> Total KMC time elapsed  </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </tottime>
               <ecache_file>
                  <help> Filename for storing/loading energy cache </help>
                  <default>  </default>
                  <dtype> string </dtype>
               </ecache_file>
               <qcache_file>
                  <help> Filename for storing/loading positions cache </help>
                  <default>  </default>
                  <dtype> string </dtype>
               </qcache_file>
               <max_cache_len>
                  <help> Maximum cache length before oldest entry is deleted </help>
                  <default> 1000 </default>
                  <dtype> integer </dtype>
               </max_cache_len>
            </al6xxx_kmc>
            <planetary mode=''>
               <help> Option for planetary model calculator </help>
               <mode_help> The constrained-centroid sampling mode.  </mode_help>
               <mode_default> md </mode_default>
               <mode_options> ['md'] </mode_options>
               <mode_dtype> string </mode_dtype>
               <thermostat mode=''>
                  <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                  <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                  <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                  <mode_dtype> string </mode_dtype>
                  <ethermo units=''>
                     <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> energy </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </ethermo>
                  <tau units=''>
                     <help> The friction coefficient for white noise thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </tau>
                  <pile_lambda>
                     <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                     <default> 1.0 </default>
                     <dtype> float </dtype>
                  </pile_lambda>
                  <pile_centroid_t units=''>
                     <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> temperature </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </pile_centroid_t>
                  <A units='' shape='' mode=''>
                     <help> The friction matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> frequency </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </A>
                  <C units='' shape='' mode=''>
                     <help> The covariance matrix for GLE thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> temperature </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </C>
                  <s units='' shape='' mode=''>
                     <help> Input values for the additional momenta in GLE. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <shape_help> The shape of the array. </shape_help>
                     <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                     <dimension> ms-momentum </dimension>
                     <default> [ ] </default>
                     <units_default> automatic </units_default>
                     <shape_default> (0,) </shape_default>
                     <mode_default> manual </mode_default>
                     <mode_options> ['manual', 'file'] </mode_options>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                     <shape_dtype> tuple </shape_dtype>
                     <mode_dtype> string </mode_dtype>
                  </s>
                  <intau units=''>
                     <help> The inherent noise time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </intau>
                  <idtau units=''>
                     <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </idtau>
                  <apat units=''>
                     <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                     <units_help> The units the input data is given in. </units_help>
                     <dimension> time </dimension>
                     <default> 0.0 </default>
                     <units_default> automatic </units_default>
                     <dtype> float </dtype>
                     <units_dtype> string </units_dtype>
                  </apat>
                  <flip>
                     <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                     <default> rescale </default>
                     <dtype> string </dtype>
                  </flip>
                  <thermostat mode=''>
                     <help> The thermostat for the atoms, keeps the atom velocity distribution at the correct temperature. </help>
                     <mode_help> The style of thermostatting. 'langevin' specifies a white noise langevin equation to be attached to the cartesian representation of the momenta. 'svr' attaches a velocity rescaling thermostat to the cartesian representation of the momenta. Both 'pile_l' and 'pile_g' attaches a white noise langevin thermostat to the normal mode representation, with 'pile_l' attaching a local langevin thermostat to the centroid mode and 'pile_g' instead attaching a global velocity rescaling thermostat. 'gle' attaches a coloured noise langevin thermostat to the cartesian representation of the momenta, 'nm_gle' attaches a coloured noise langevin thermostat to the normal mode representation of the momenta and a langevin thermostat to the centroid and 'nm_gle_g' attaches a gle thermostat to the normal modes and a svr thermostat to the centroid. 'cl' represents a modified langevin thermostat which compensates for additional white noise from noisy forces or for dissipative effects. 'ffl' is the fast-forward langevin thermostat, in which momenta are flipped back whenever the action of the thermostat changes its direction. 'multiple' is a special thermostat mode, in which one can define multiple thermostats _inside_ the thermostat tag. </mode_help>
                     <mode_options> ['', 'langevin', 'svr', 'pile_l', 'pile_g', 'gle', 'nm_gle', 'nm_gle_g', 'cl', 'ffl', 'multi'] </mode_options>
                     <mode_dtype> string </mode_dtype>
                     <ethermo units=''>
                        <help> The initial value of the thermostat energy. Used when the simulation is restarted to guarantee continuity of the conserved quantity. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> energy </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </ethermo>
                     <tau units=''>
                        <help> The friction coefficient for white noise thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </tau>
                     <pile_lambda>
                        <help> Scaling for the PILE damping relative to the critical damping. (gamma_k=2*lambda*omega_k </help>
                        <default> 1.0 </default>
                        <dtype> float </dtype>
                     </pile_lambda>
                     <pile_centroid_t units=''>
                        <help> Option to set a different centroid temperature wrt. that of the ensemble. Only used if value other than 0.0. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> temperature </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </pile_centroid_t>
                     <A units='' shape='' mode=''>
                        <help> The friction matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> frequency </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </A>
                     <C units='' shape='' mode=''>
                        <help> The covariance matrix for GLE thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> temperature </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </C>
                     <s units='' shape='' mode=''>
                        <help> Input values for the additional momenta in GLE. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <shape_help> The shape of the array. </shape_help>
                        <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                        <dimension> ms-momentum </dimension>
                        <default> [ ] </default>
                        <units_default> automatic </units_default>
                        <shape_default> (0,) </shape_default>
                        <mode_default> manual </mode_default>
                        <mode_options> ['manual', 'file'] </mode_options>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                        <shape_dtype> tuple </shape_dtype>
                        <mode_dtype> string </mode_dtype>
                     </s>
                     <intau units=''>
                        <help> The inherent noise time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </intau>
                     <idtau units=''>
                        <help> The inherent dissipation time scale for compensating langevin thermostats. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </idtau>
                     <apat units=''>
                        <help> The time scale for automatic adjustment of CL thermostat's parameters. </help>
                        <units_help> The units the input data is given in. </units_help>
                        <dimension> time </dimension>
                        <default> 0.0 </default>
                        <units_default> automatic </units_default>
                        <dtype> float </dtype>
                        <units_dtype> string </units_dtype>
                     </apat>
                     <flip>
                        <help> Flipping type for ffl thermostat ('soft', 'hard', 'rescale', 'none') </help>
                        <default> rescale </default>
                        <dtype> string </dtype>
                     </flip>
                  </thermostat>
               </thermostat>
               <timestep units=''>
                  <help> The time step. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> time </dimension>
                  <default> 1.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </timestep>
               <nmts shape='' mode=''>
                  <help> Number of iterations for each MTS level (including the outer loop, that should in most cases have just one iteration). </help>
                  <shape_help> The shape of the array. </shape_help>
                  <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
                  <default> [ ] </default>
                  <shape_default> (0,) </shape_default>
                  <mode_default> manual </mode_default>
                  <mode_options> ['manual', 'file'] </mode_options>
                  <dtype> integer </dtype>
                  <shape_dtype> tuple </shape_dtype>
                  <mode_dtype> string </mode_dtype>
               </nmts>
               <nsamples>
                  <help> Number of samples to accumulate for each planetary step. </help>
                  <default> 0 </default>
                  <dtype> integer </dtype>
               </nsamples>
               <stride>
                  <help> How often the planetary calculation should actually be triggered. </help>
                  <default> 1 </default>
                  <dtype> integer </dtype>
               </stride>
               <nbeads>
                  <help> Number of beads for centroid-constrained dynamics (default same as master trajectory) </help>
                  <default> -1 </default>
                  <dtype> integer </dtype>
               </nbeads>
               <screen units=''>
                  <help> Screening parameter for path-integral frequency matrix. </help>
                  <units_help> The units the input data is given in. </units_help>
                  <dimension> length </dimension>
                  <default> 0.0 </default>
                  <units_default> automatic </units_default>
                  <dtype> float </dtype>
                  <units_dtype> string </units_dtype>
               </screen>
            </planetary>
         </motion>
      </motion>
      <beads natoms='' nbeads=''>
         <help> Describes the bead configurations in a path integral simulation. </help>
         <natoms_help> The number of atoms. </natoms_help>
         <nbeads_help> The number of beads. </nbeads_help>
         <natoms_default> 0 </natoms_default>
         <nbeads_default> 0 </nbeads_default>
         <natoms_dtype> integer </natoms_dtype>
         <nbeads_dtype> integer </nbeads_dtype>
         <q units='' shape='' mode=''>
            <help> The positions of the beads. In an array of size [nbeads, 3*natoms]. </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> length </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </q>
         <p units='' shape='' mode=''>
            <help> The momenta of the beads. In an array of size [nbeads, 3*natoms]. </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> momentum </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </p>
         <m units='' shape='' mode=''>
            <help> The masses of the atoms, in the format [m1, m2, ... ]. </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> mass </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </m>
         <names shape='' mode=''>
            <help> The names of the atoms, in the format [name1, name2, ... ]. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> string </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </names>
      </beads>
      <normal_modes transform='' propagator=''>
         <help> Deals with the normal mode transformations, including the adjustment of bead masses to give the desired ring polymer normal mode frequencies if appropriate. Takes as arguments frequencies, of which different numbers must be specified and which are used to scale the normal mode frequencies in different ways depending on which 'mode' is specified. </help>
         <transform_help> Specifies whether to calculate the normal mode transform using a fast Fourier transform or a matrix multiplication. For small numbers of beads the matrix multiplication may be faster. </transform_help>
         <propagator_help> How to propagate the free ring polymer dynamics. Cayley transform is not exact but is strongly stable and avoid potential resonance issues. A bab scheme performs numerical verlet type propagation. All three options work for distinguishable particles. Only the bab propagator can be used with bosonic particles. </propagator_help>
         <transform_default> fft </transform_default>
         <propagator_default> exact </propagator_default>
         <transform_options> ['fft', 'matrix'] </transform_options>
         <propagator_options> ['exact', 'cayley', 'bab'] </propagator_options>
         <transform_dtype> string </transform_dtype>
         <propagator_dtype> string </propagator_dtype>
         <frequencies units='' shape='' mode='' style=''>
            <help> Specifies normal mode frequencies for a (closed path) calculation </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <style_help> 
Specifies the technique to be used to calculate the dynamical masses.
'rpmd' simply assigns the bead masses the physical mass.
'manual' sets all the normal mode frequencies except the centroid normal mode manually.
'pa-cmd' takes an argument giving the frequency to set all the non-centroid normal modes to.
'wmax-cmd' is similar to 'pa-cmd', except instead of taking one argument it takes two
([wmax,wtarget]). The lowest-lying normal mode will be set to wtarget for a
free particle, and all the normal modes will coincide at frequency wmax. 
 </style_help>
            <dimension> frequency </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <style_default> rpmd </style_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <style_options> ['pa-cmd', 'wmax-cmd', 'manual', 'rpmd'] </style_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
            <style_dtype> string </style_dtype>
         </frequencies>
         <open_paths shape='' mode=''>
            <help> Indices of the atoms whose path should be opened (zero-based). </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </open_paths>
         <bosons shape='' mode='' id=''>
            <help> Specify which atoms are bosons. </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <id_help> If 'id' is 'index', then bosonic atoms are specified a list of indices (zero-based). If 'id' is 'label' then specify a list of labels. </id_help>
            <default> [ ] </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <id_default> index </id_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <id_options> ['index', 'label'] </id_options>
            <dtype> string </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
            <id_dtype> string </id_dtype>
         </bosons>
         <nmts>
            <help> The number of iterations to perform one bab step. </help>
            <default> 1 </default>
            <dtype> integer </dtype>
         </nmts>
      </normal_modes>
      <cell units='' shape='' mode=''>
         <help> 
Describes with the cell parameters. Takes as array which can be used to initialize the cell vector matrix.
N.B.: the cell parameters are stored with the lattice vectors in the columns, and the cell must be oriented
in such a way that the array is upper-triangular (i.e. with the first vector aligned along x and the second
vector in the xy plane).     
 </help>
         <units_help> The units the input data is given in. </units_help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <dimension> length </dimension>
         <default>
            [0. 0. 0. 0. 0. 0. 0. 0. 0.]
         </default>
         <units_default> automatic </units_default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </cell>
   </system>
   <system_template>
      <help> Generic input value </help>
      <template>
         <help>  A string that will be read verbatim containing the model for a system to be generated </help>
         <dtype> string </dtype>
      </template>
      <labels shape='' mode=''>
         <help>  A list of strings that should be substituted in the template to create multiple systems  </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> string </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </labels>
      <instance shape='' mode=''>
         <help>  A list of strings that should the labels creating one system instance  </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> string </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </instance>
   </system_template>
   <ffsocket mode='' matching='' name='' pbc='' threaded=''>
      <help> Deals with the assigning of force calculation jobs to different driver codes, and collecting the data, using a socket for the data communication. </help>
      <mode_help> Specifies whether the driver interface will listen onto a internet socket [inet] or onto a unix socket [unix]. </mode_help>
      <matching_help> Specifies whether requests should be dispatched to any client, automatically matched to the same client when possible [auto] or strictly forced to match with the same client [lock]. </matching_help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial. Should be set to True for FFSockets </threaded_help>
      <mode_default> inet </mode_default>
      <matching_default> auto </matching_default>
      <pbc_default> True </pbc_default>
      <threaded_default> True </threaded_default>
      <mode_options> ['unix', 'inet'] </mode_options>
      <matching_options> ['auto', 'any', 'lock'] </matching_options>
      <mode_dtype> string </mode_dtype>
      <matching_dtype> string </matching_dtype>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <address>
         <help> This gives the server address that the socket will run on. </help>
         <default> localhost </default>
         <dtype> string </dtype>
      </address>
      <port>
         <help> This gives the port number that defines the socket. </help>
         <default> 65535 </default>
         <dtype> integer </dtype>
      </port>
      <slots>
         <help> This gives the number of client codes that can queue at any one time. </help>
         <default> 4 </default>
         <dtype> integer </dtype>
      </slots>
      <exit_on_disconnect>
         <help> Determines if i-PI should quit when a client disconnects. </help>
         <default> False </default>
         <dtype> boolean </dtype>
      </exit_on_disconnect>
      <timeout>
         <help> This gives the number of seconds before assuming a calculation has died. If 0 there is no timeout. </help>
         <default> 0.0 </default>
         <dtype> float </dtype>
      </timeout>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffsocket>
   <fflj name='' pbc='' threaded=''>
      <help> Simple, internal LJ evaluator without cutoff, neighbour lists or minimal image convention.
                   Expects standard LJ parameters, e.g. { eps: 0.1, sigma: 1.0 }.  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </fflj>
   <ffdmd name='' pbc='' threaded=''>
      <help> Simple, internal DMD evaluator without without neighbor lists, but with PBC.
                   Expects coupling elements (n*(n-1)/2 of them), oscillating frequency and time step.  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <dmd_coupling shape='' mode=''>
         <help> Specifies the coupling between atom pairs (should be size N*(N-1)/2 ordered c21, c32, c31, c43, c42, c41 etc.  -- in atomic units!) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default> [ ] </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </dmd_coupling>
      <dmd_freq units=''>
         <help> Frequency of the oscillation of the time-dependent term </help>
         <units_help> The units the input data is given in. </units_help>
         <dimension> frequency </dimension>
         <default> 0.0 </default>
         <units_default> automatic </units_default>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
      </dmd_freq>
      <dmd_dt units=''>
         <help> Time step of the oscillating potential. Should match time step of simulation </help>
         <units_help> The units the input data is given in. </units_help>
         <dimension> time </dimension>
         <default> 0.0 </default>
         <units_default> automatic </units_default>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
      </dmd_dt>
      <dmd_step>
         <help> The current step counter for dmd. </help>
         <default> 0 </default>
         <dtype> integer </dtype>
      </dmd_step>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffdmd>
   <ffdebye name='' pbc='' threaded=''>
      <help> Harmonic energy calculator  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <hessian units='' shape='' mode=''>
         <help> Specifies the Hessian of the harmonic potential. Default units are atomic. Units can be specified only by xml attribute. Implemented options are: 'atomic_unit', 'ev/ang\^2' </help>
         <units_help> The units the input data is given in. </units_help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <dimension> hessian </dimension>
         <default> [ ] </default>
         <units_default> automatic </units_default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </hessian>
      <x_reference units='' shape='' mode=''>
         <help> Minimum-energy configuration for the harmonic potential </help>
         <units_help> The units the input data is given in. </units_help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <dimension> length </dimension>
         <default> [ ] </default>
         <units_default> automatic </units_default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </x_reference>
      <v_reference units=''>
         <help> Zero-value of energy for the harmonic potential </help>
         <units_help> The units the input data is given in. </units_help>
         <dimension> energy </dimension>
         <default> 0.0 </default>
         <units_default> automatic </units_default>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
      </v_reference>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffdebye>
   <ffplumed name='' pbc='' threaded=''>
      <help>  Direct PLUMED interface  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <file mode='' bead='' cell_units=''>
         <help> This describes the location to read the reference structure file from. </help>
         <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 
        'chk' stands for initialization from a checkpoint file. 'ase' is to read a file with the Atomic Simulation Environment </mode_help>
         <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
         <cell_units_help> The units for the cell dimensions. </cell_units_help>
         <default>  </default>
         <mode_default> chk </mode_default>
         <bead_default> -1 </bead_default>
         <cell_units_default> automatic </cell_units_default>
         <mode_options> ['xyz', 'pdb', 'chk', 'ase'] </mode_options>
         <dtype> string </dtype>
         <mode_dtype> string </mode_dtype>
         <bead_dtype> integer </bead_dtype>
         <cell_units_dtype> string </cell_units_dtype>
      </file>
      <plumeddat>
         <help> The PLUMED input file </help>
         <default> plumed.dat </default>
         <dtype> string </dtype>
      </plumeddat>
      <plumedstep>
         <help> The current step counter for PLUMED calls </help>
         <default> 0 </default>
         <dtype> integer </dtype>
      </plumedstep>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffplumed>
   <ffyaff name='' pbc='' threaded=''>
      <help> Uses a Yaff force field to compute the forces. </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <yaffpara>
         <help> This gives the file name of the Yaff input parameter file. </help>
         <default> parameters.txt </default>
         <dtype> string </dtype>
      </yaffpara>
      <yaffsys>
         <help> This gives the file name of the Yaff input system file. </help>
         <default> system.chk </default>
         <dtype> string </dtype>
      </yaffsys>
      <yafflog>
         <help> This gives the file name of the Yaff output log file. </help>
         <default> yaff.log </default>
         <dtype> string </dtype>
      </yafflog>
      <rcut>
         <help> This gives the real space cutoff used by all pair potentials in atomic units. </help>
         <default> 18.89726133921252 </default>
         <dtype> float </dtype>
      </rcut>
      <alpha_scale>
         <help> This gives the alpha parameter in the Ewald summation based on the real-space cutoff: alpha = alpha_scale / rcut. Higher values for this parameter imply a faster convergence of the reciprocal terms, but a slower convergence in real-space. </help>
         <default> 3.5 </default>
         <dtype> float </dtype>
      </alpha_scale>
      <gcut_scale>
         <help> This gives the reciprocale space cutoff based on the alpha parameter: gcut = gcut_scale * alpha. Higher values for this parameter imply a better convergence in the reciprocal space. </help>
         <default> 1.1 </default>
         <dtype> float </dtype>
      </gcut_scale>
      <skin>
         <help> This gives the skin parameter for the neighborlist. </help>
         <default> 0 </default>
         <dtype> integer </dtype>
      </skin>
      <smooth_ei>
         <help> This gives the flag for smooth truncations for the electrostatic interactions. </help>
         <default> False </default>
         <dtype> boolean </dtype>
      </smooth_ei>
      <reci_ei>
         <help> This gives the method to be used for the reciprocal contribution to the electrostatic interactions in the case of periodic systems. This must be one of 'ignore' or 'ewald'. The 'ewald' option is only supported for 3D periodic systems. </help>
         <default> ewald </default>
         <dtype> string </dtype>
      </reci_ei>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffyaff>
   <ffcommittee name='' pbc='' threaded=''>
      <help> Combines multiple forcefields to build a committee model, that can 
                      be used to compute uncertainty-quantified machine-learning models. 
                      Each forcefield can be any of the other FF objects, and each should
                      be used with a client that generates a slightly different estimation
                      of energy and forces. These are averaged, and the mean used as the 
                      actual forcefield. Statistics about the distribution are also returned
                      as extras fields, and can be printed for further postprocessing. 
                      Also contains options to use it for uncertainty estimation and for
                      active learning in a ML context, based on a committee model.
                      Implements the approaches discussed in DOI: 10.1063/5.0036522.
                       </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
      <weights shape='' mode=''>
         <help> List of weights to be given to the forcefields. Defaults to 1 for each FF. 
                Note that the components are divided by the number of FF, and so the default corresponds to an average. </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default> [ ] </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </weights>
      <alpha>
         <help> Scaling of the variance of the model, corresponding to a calibration of the error  </help>
         <default> 1.0 </default>
         <dtype> float </dtype>
      </alpha>
      <baseline_name>
         <help> Name of the forcefield object that should be treated as the baseline for a weighted baseline model. </help>
         <default>  </default>
         <dtype> string </dtype>
      </baseline_name>
      <baseline_uncertainty units=''>
         <help> Corresponds to the expected error of the baseline model. This represents the error on the TOTAL potential energy of the simulation.  </help>
         <units_help> The units the input data is given in. </units_help>
         <dimension> energy </dimension>
         <default> -1.0 </default>
         <units_default> automatic </units_default>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
      </baseline_uncertainty>
      <active_thresh units=''>
         <help> The uncertainty threshold for active learning. Structure with an uncertainty above this 
                        value are printed in the specified output file so they can be used for active learning. </help>
         <units_help> The units the input data is given in. </units_help>
         <dimension> energy </dimension>
         <default> 0.0 </default>
         <units_default> automatic </units_default>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
      </active_thresh>
      <active_output>
         <help> Output filename for structures that exceed the accuracy threshold of the model, to be used in active learning. </help>
         <default> active_output </default>
         <dtype> string </dtype>
      </active_output>
      <ffsocket mode='' matching='' name='' pbc='' threaded=''>
         <help> Deals with the assigning of force calculation jobs to different driver codes, and collecting the data, using a socket for the data communication. </help>
         <mode_help> Specifies whether the driver interface will listen onto a internet socket [inet] or onto a unix socket [unix]. </mode_help>
         <matching_help> Specifies whether requests should be dispatched to any client, automatically matched to the same client when possible [auto] or strictly forced to match with the same client [lock]. </matching_help>
         <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
         <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
         <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial. Should be set to True for FFSockets </threaded_help>
         <mode_default> inet </mode_default>
         <matching_default> auto </matching_default>
         <pbc_default> True </pbc_default>
         <threaded_default> True </threaded_default>
         <mode_options> ['unix', 'inet'] </mode_options>
         <matching_options> ['auto', 'any', 'lock'] </matching_options>
         <mode_dtype> string </mode_dtype>
         <matching_dtype> string </matching_dtype>
         <name_dtype> string </name_dtype>
         <pbc_dtype> boolean </pbc_dtype>
         <threaded_dtype> boolean </threaded_dtype>
         <address>
            <help> This gives the server address that the socket will run on. </help>
            <default> localhost </default>
            <dtype> string </dtype>
         </address>
         <port>
            <help> This gives the port number that defines the socket. </help>
            <default> 65535 </default>
            <dtype> integer </dtype>
         </port>
         <slots>
            <help> This gives the number of client codes that can queue at any one time. </help>
            <default> 4 </default>
            <dtype> integer </dtype>
         </slots>
         <exit_on_disconnect>
            <help> Determines if i-PI should quit when a client disconnects. </help>
            <default> False </default>
            <dtype> boolean </dtype>
         </exit_on_disconnect>
         <timeout>
            <help> This gives the number of seconds before assuming a calculation has died. If 0 there is no timeout. </help>
            <default> 0.0 </default>
            <dtype> float </dtype>
         </timeout>
         <latency>
            <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
            <default> 0.0001 </default>
            <dtype> float </dtype>
         </latency>
         <parameters>
            <help> The parameters of the force field </help>
            <default> { } </default>
            <dtype> dictionary </dtype>
         </parameters>
         <activelist shape='' mode=''>
            <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default>
               [-1]
            </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </activelist>
      </ffsocket>
      <fflj name='' pbc='' threaded=''>
         <help> Simple, internal LJ evaluator without cutoff, neighbour lists or minimal image convention.
                   Expects standard LJ parameters, e.g. { eps: 0.1, sigma: 1.0 }.  </help>
         <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
         <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
         <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
         <pbc_default> True </pbc_default>
         <threaded_default> False </threaded_default>
         <name_dtype> string </name_dtype>
         <pbc_dtype> boolean </pbc_dtype>
         <threaded_dtype> boolean </threaded_dtype>
         <latency>
            <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
            <default> 0.0001 </default>
            <dtype> float </dtype>
         </latency>
         <parameters>
            <help> The parameters of the force field </help>
            <default> { } </default>
            <dtype> dictionary </dtype>
         </parameters>
         <activelist shape='' mode=''>
            <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default>
               [-1]
            </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </activelist>
      </fflj>
      <ffdebye name='' pbc='' threaded=''>
         <help> Harmonic energy calculator  </help>
         <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
         <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
         <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
         <pbc_default> True </pbc_default>
         <threaded_default> False </threaded_default>
         <name_dtype> string </name_dtype>
         <pbc_dtype> boolean </pbc_dtype>
         <threaded_dtype> boolean </threaded_dtype>
         <hessian units='' shape='' mode=''>
            <help> Specifies the Hessian of the harmonic potential. Default units are atomic. Units can be specified only by xml attribute. Implemented options are: 'atomic_unit', 'ev/ang\^2' </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> hessian </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </hessian>
         <x_reference units='' shape='' mode=''>
            <help> Minimum-energy configuration for the harmonic potential </help>
            <units_help> The units the input data is given in. </units_help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <dimension> length </dimension>
            <default> [ ] </default>
            <units_default> automatic </units_default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </x_reference>
         <v_reference units=''>
            <help> Zero-value of energy for the harmonic potential </help>
            <units_help> The units the input data is given in. </units_help>
            <dimension> energy </dimension>
            <default> 0.0 </default>
            <units_default> automatic </units_default>
            <dtype> float </dtype>
            <units_dtype> string </units_dtype>
         </v_reference>
         <latency>
            <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
            <default> 0.0001 </default>
            <dtype> float </dtype>
         </latency>
         <parameters>
            <help> The parameters of the force field </help>
            <default> { } </default>
            <dtype> dictionary </dtype>
         </parameters>
         <activelist shape='' mode=''>
            <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default>
               [-1]
            </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </activelist>
      </ffdebye>
      <ffplumed name='' pbc='' threaded=''>
         <help>  Direct PLUMED interface  </help>
         <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
         <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
         <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
         <pbc_default> True </pbc_default>
         <threaded_default> False </threaded_default>
         <name_dtype> string </name_dtype>
         <pbc_dtype> boolean </pbc_dtype>
         <threaded_dtype> boolean </threaded_dtype>
         <file mode='' bead='' cell_units=''>
            <help> This describes the location to read the reference structure file from. </help>
            <mode_help> The input data format. 'xyz' and 'pdb' stand for xyz and pdb input files respectively. 
        'chk' stands for initialization from a checkpoint file. 'ase' is to read a file with the Atomic Simulation Environment </mode_help>
            <bead_help> The index of the bead for which the value will be set. If a negative value is specified, then all beads are assumed. </bead_help>
            <cell_units_help> The units for the cell dimensions. </cell_units_help>
            <default>  </default>
            <mode_default> chk </mode_default>
            <bead_default> -1 </bead_default>
            <cell_units_default> automatic </cell_units_default>
            <mode_options> ['xyz', 'pdb', 'chk', 'ase'] </mode_options>
            <dtype> string </dtype>
            <mode_dtype> string </mode_dtype>
            <bead_dtype> integer </bead_dtype>
            <cell_units_dtype> string </cell_units_dtype>
         </file>
         <plumeddat>
            <help> The PLUMED input file </help>
            <default> plumed.dat </default>
            <dtype> string </dtype>
         </plumeddat>
         <plumedstep>
            <help> The current step counter for PLUMED calls </help>
            <default> 0 </default>
            <dtype> integer </dtype>
         </plumedstep>
         <latency>
            <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
            <default> 0.0001 </default>
            <dtype> float </dtype>
         </latency>
         <parameters>
            <help> The parameters of the force field </help>
            <default> { } </default>
            <dtype> dictionary </dtype>
         </parameters>
         <activelist shape='' mode=''>
            <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default>
               [-1]
            </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </activelist>
      </ffplumed>
      <ffyaff name='' pbc='' threaded=''>
         <help> Uses a Yaff force field to compute the forces. </help>
         <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
         <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
         <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
         <pbc_default> True </pbc_default>
         <threaded_default> False </threaded_default>
         <name_dtype> string </name_dtype>
         <pbc_dtype> boolean </pbc_dtype>
         <threaded_dtype> boolean </threaded_dtype>
         <yaffpara>
            <help> This gives the file name of the Yaff input parameter file. </help>
            <default> parameters.txt </default>
            <dtype> string </dtype>
         </yaffpara>
         <yaffsys>
            <help> This gives the file name of the Yaff input system file. </help>
            <default> system.chk </default>
            <dtype> string </dtype>
         </yaffsys>
         <yafflog>
            <help> This gives the file name of the Yaff output log file. </help>
            <default> yaff.log </default>
            <dtype> string </dtype>
         </yafflog>
         <rcut>
            <help> This gives the real space cutoff used by all pair potentials in atomic units. </help>
            <default> 18.89726133921252 </default>
            <dtype> float </dtype>
         </rcut>
         <alpha_scale>
            <help> This gives the alpha parameter in the Ewald summation based on the real-space cutoff: alpha = alpha_scale / rcut. Higher values for this parameter imply a faster convergence of the reciprocal terms, but a slower convergence in real-space. </help>
            <default> 3.5 </default>
            <dtype> float </dtype>
         </alpha_scale>
         <gcut_scale>
            <help> This gives the reciprocale space cutoff based on the alpha parameter: gcut = gcut_scale * alpha. Higher values for this parameter imply a better convergence in the reciprocal space. </help>
            <default> 1.1 </default>
            <dtype> float </dtype>
         </gcut_scale>
         <skin>
            <help> This gives the skin parameter for the neighborlist. </help>
            <default> 0 </default>
            <dtype> integer </dtype>
         </skin>
         <smooth_ei>
            <help> This gives the flag for smooth truncations for the electrostatic interactions. </help>
            <default> False </default>
            <dtype> boolean </dtype>
         </smooth_ei>
         <reci_ei>
            <help> This gives the method to be used for the reciprocal contribution to the electrostatic interactions in the case of periodic systems. This must be one of 'ignore' or 'ewald'. The 'ewald' option is only supported for 3D periodic systems. </help>
            <default> ewald </default>
            <dtype> string </dtype>
         </reci_ei>
         <latency>
            <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
            <default> 0.0001 </default>
            <dtype> float </dtype>
         </latency>
         <parameters>
            <help> The parameters of the force field </help>
            <default> { } </default>
            <dtype> dictionary </dtype>
         </parameters>
         <activelist shape='' mode=''>
            <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default>
               [-1]
            </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </activelist>
      </ffyaff>
      <ffsgdml name='' pbc='' threaded=''>
         <help> A SGDML energy calculator  </help>
         <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
         <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
         <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
         <pbc_default> True </pbc_default>
         <threaded_default> False </threaded_default>
         <name_dtype> string </name_dtype>
         <pbc_dtype> boolean </pbc_dtype>
         <threaded_dtype> boolean </threaded_dtype>
         <sGDML_model>
            <help> This gives the file name of the sGDML model. </help>
            <dtype> string </dtype>
         </sGDML_model>
         <latency>
            <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
            <default> 0.0001 </default>
            <dtype> float </dtype>
         </latency>
         <parameters>
            <help> The parameters of the force field </help>
            <default> { } </default>
            <dtype> dictionary </dtype>
         </parameters>
         <activelist shape='' mode=''>
            <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
            <shape_help> The shape of the array. </shape_help>
            <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
            <default>
               [-1]
            </default>
            <shape_default> (0,) </shape_default>
            <mode_default> manual </mode_default>
            <mode_options> ['manual', 'file'] </mode_options>
            <dtype> integer </dtype>
            <shape_dtype> tuple </shape_dtype>
            <mode_dtype> string </mode_dtype>
         </activelist>
      </ffsgdml>
   </ffcommittee>
   <ffsgdml name='' pbc='' threaded=''>
      <help> A SGDML energy calculator  </help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial </threaded_help>
      <pbc_default> True </pbc_default>
      <threaded_default> False </threaded_default>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <sGDML_model>
         <help> This gives the file name of the sGDML model. </help>
         <dtype> string </dtype>
      </sGDML_model>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffsgdml>
   <ffcavphsocket mode='' matching='' name='' pbc='' threaded=''>
      <help> A cavity molecular dynamics driver for vibraitonal strong coupling. 
                      In the current implementation, only a single cavity mode polarized along the x and y directions is coupled to the molecules.
                      Check https://doi.org/10.1073/pnas.2009272117 and also examples/lammps/h2o-cavmd/ for details.
                    </help>
      <mode_help> Specifies whether the driver interface will listen onto a internet socket [inet] or onto a unix socket [unix]. </mode_help>
      <matching_help> Specifies whether requests should be dispatched to any client, automatically matched to the same client when possible [auto] or strictly forced to match with the same client [lock]. </matching_help>
      <name_help> Mandatory. The name by which the forcefield will be identified in the System forces section. </name_help>
      <pbc_help> Applies periodic boundary conditions to the atoms coordinates before passing them on to the driver code. </pbc_help>
      <threaded_help> Whether the forcefield should use a thread loop to evaluate, or work in serial. Should be set to True for FFSockets </threaded_help>
      <mode_default> inet </mode_default>
      <matching_default> auto </matching_default>
      <pbc_default> True </pbc_default>
      <threaded_default> True </threaded_default>
      <mode_options> ['unix', 'inet'] </mode_options>
      <matching_options> ['auto', 'any', 'lock'] </matching_options>
      <mode_dtype> string </mode_dtype>
      <matching_dtype> string </matching_dtype>
      <name_dtype> string </name_dtype>
      <pbc_dtype> boolean </pbc_dtype>
      <threaded_dtype> boolean </threaded_dtype>
      <charge_array units='' shape='' mode=''>
         <help> The partial charges of all the atoms, in the format [Q1, Q2, ... ]. </help>
         <units_help> The units the input data is given in. </units_help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <dimension> length </dimension>
         <default> [ ] </default>
         <units_default> automatic </units_default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </charge_array>
      <apply_photon>
         <help> Determines if additional photonic degrees of freedom is included or not. </help>
         <default> False </default>
         <dtype> boolean </dtype>
      </apply_photon>
      <E0>
         <help> The value of varepsilon (effective light-matter coupling strength) in atomic units. </help>
         <default> 0.0 </default>
         <dtype> float </dtype>
      </E0>
      <omega_c units=''>
         <help> This gives the cavity photon frequency at normal incidence. </help>
         <units_help> The units the input data is given in. </units_help>
         <dimension> frequency </dimension>
         <default> 0.01 </default>
         <units_default> automatic </units_default>
         <dtype> float </dtype>
         <units_dtype> string </units_dtype>
      </omega_c>
      <ph_rep>
         <help> In the current implementation, two energy-degenerate photon modes polarized along x and y directions
                are coupled to the molecular system. If 'loose', the cavity photons polarized along the x, y directions are represented by two 'L' atoms; 
                the x dimension of the first 'L' atom is coupled to the molecules, and the y dimension of the second 'L' atom is coupled to the molecules.
                If 'dense', the cavity photons polarized along the x, y directions are represented by one 'L' atom; 
                the x and y dimensions of this 'L' atom are coupled to the molecules. </help>
         <default> loose </default>
         <options> ['loose', 'dense'] </options>
         <dtype> string </dtype>
      </ph_rep>
      <address>
         <help> This gives the server address that the socket will run on. </help>
         <default> localhost </default>
         <dtype> string </dtype>
      </address>
      <port>
         <help> This gives the port number that defines the socket. </help>
         <default> 65535 </default>
         <dtype> integer </dtype>
      </port>
      <slots>
         <help> This gives the number of client codes that can queue at any one time. </help>
         <default> 4 </default>
         <dtype> integer </dtype>
      </slots>
      <exit_on_disconnect>
         <help> Determines if i-PI should quit when a client disconnects. </help>
         <default> False </default>
         <dtype> boolean </dtype>
      </exit_on_disconnect>
      <timeout>
         <help> This gives the number of seconds before assuming a calculation has died. If 0 there is no timeout. </help>
         <default> 0.0 </default>
         <dtype> float </dtype>
      </timeout>
      <latency>
         <help> The number of seconds the polling thread will wait between exhamining the list of requests. </help>
         <default> 0.0001 </default>
         <dtype> float </dtype>
      </latency>
      <parameters>
         <help> The parameters of the force field </help>
         <default> { } </default>
         <dtype> dictionary </dtype>
      </parameters>
      <activelist shape='' mode=''>
         <help> List with indexes of the atoms that this socket is taking care of.    Default: [-1] (corresponding to all) </help>
         <shape_help> The shape of the array. </shape_help>
         <mode_help> If 'mode' is 'manual', then the array is read in directly, then reshaped according to the 'shape' specified in a row-major manner. If 'mode' is 'file' then the array is read in from the file given. </mode_help>
         <default>
            [-1]
         </default>
         <shape_default> (0,) </shape_default>
         <mode_default> manual </mode_default>
         <mode_options> ['manual', 'file'] </mode_options>
         <dtype> integer </dtype>
         <shape_dtype> tuple </shape_dtype>
         <mode_dtype> string </mode_dtype>
      </activelist>
   </ffcavphsocket>
</simulation>
